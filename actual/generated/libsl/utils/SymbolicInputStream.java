// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - libsl/utils/SymbolicInputStream.lsl:15
//  - libsl/utils/SymbolicInputStream.main.lsl:16
//
package generated.libsl.utils;

import java.io.IOException;
import java.io.OutputStream;
import java.lang.IllegalArgumentException;
import java.lang.IndexOutOfBoundsException;
import java.lang.NullPointerException;
import java.lang.SuppressWarnings;
import java.lang.Void;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * SymbolicInputStreamAutomaton for SymbolicInputStream ~> libsl.utils.SymbolicInputStream
 */
@SuppressWarnings({"all", "unchecked"})
@Approximate(stub.libsl.utils.SymbolicInputStream.class)
public final class SymbolicInputStream implements LibSLRuntime.Automaton {
    static {
        Engine.assume(true);
    }

    public final int maxSize;

    public final boolean supportMarks;

    public volatile int dataSize;

    public volatile byte[] data;

    public volatile boolean closed;

    public volatile int pos;

    public int markPos;

    public int markLimit;

    @LibSLRuntime.AutomatonConstructor
    public SymbolicInputStream(Void __$lsl_token, final byte p0, final int p1, final boolean p2,
            final int p3, final byte[] p4, final boolean p5, final int p6, final int p7,
            final int p8) {
        this.maxSize = p1;
        this.supportMarks = p2;
        this.dataSize = p3;
        this.data = p4;
        this.closed = p5;
        this.pos = p6;
        this.markPos = p7;
        this.markLimit = p8;
    }

    @LibSLRuntime.AutomatonConstructor
    public SymbolicInputStream(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, 0, false, -1, null, false, 0, -1, 0);
    }

    /**
     * [SUBROUTINE] SymbolicInputStreamAutomaton::_initBuffer() -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:57
     */
    private void _initBuffer() {
        /* body */ {
            if (this.data == null) {
                Engine.assume(this.maxSize > 0);
                final int newSize = Engine.makeSymbolicInt();
                Engine.assume(0 <= newSize);
                Engine.assume(newSize < this.maxSize);
                this.dataSize = newSize;
                if (newSize == 0) {
                    this.data = new byte[0];
                } else {
                    this.data = Engine.makeSymbolicByteArray(newSize);
                }
                Engine.assume(this.data != null);
                Engine.assume(this.dataSize == this.data.length);
            }
        }
    }

    /**
     * [SUBROUTINE] SymbolicInputStreamAutomaton::_checkFromIndexSize(int, int, int) -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:99
     */
    private void _checkFromIndexSize(int fromIndex, int size, int length) {
        /* body */ {
            if (((length | fromIndex | size) < 0) || (size > (length - fromIndex))) {
                throw new IndexOutOfBoundsException("Range [%s, %<s + %s) out of bounds for length %s");
            }
        }
    }

    /**
     * [SUBROUTINE] SymbolicInputStreamAutomaton::_updatePosition(int) -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:107
     */
    private void _updatePosition(int delta) {
        /* body */ {
            this.pos += delta;
            if (this.markPos != -1) {
                if (this.pos >= this.markLimit) {
                    this.markPos = -1;
                }
            }
        }
    }

    /**
     * [SUBROUTINE] SymbolicInputStreamAutomaton::_moveDataTo(array<byte>, int, int) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:117
     */
    private int _moveDataTo(byte[] dest, int offset, int count) {
        int result = 0;
        /* body */ {
            result = 0;
            final int available = this.dataSize - this.pos;
            if (available != 0) {
                Engine.assume(available > 0);
                if (available < count) {
                    count = available;
                }
                LibSLRuntime.ArrayActions.copy(this.data, this.pos, dest, offset, count);
                _updatePosition(count);
                result = count;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::available(SymbolicInputStream) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:143
     */
    public int available() throws java.io.IOException {
        int result = 0;
        /* body */ {
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            result = this.dataSize - this.pos;
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::close(SymbolicInputStream) -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:151
     */
    public void close() throws java.io.IOException {
        /* body */ {
            this.closed = true;
        }
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::mark(SymbolicInputStream, int) -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:159
     */
    public void mark(int readlimit) {
        /* body */ {
            if (this.supportMarks) {
                this.markPos = this.pos;
                this.markLimit = readlimit;
            }
        }
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::markSupported(SymbolicInputStream) -> boolean
     * Source: libsl/utils/SymbolicInputStream.main.lsl:170
     */
    public boolean markSupported() {
        boolean result = false;
        /* body */ {
            result = this.supportMarks;
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::read(SymbolicInputStream) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:176
     */
    public int read() throws java.io.IOException {
        int result = 0;
        /* body */ {
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            result = -1;
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::read(SymbolicInputStream, array<byte>) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:184
     */
    public int read(byte[] b) throws java.io.IOException {
        int result = 0;
        /* body */ {
            final int len = b.length;
            if (len == 0) {
                result = 0;
            } else {
                Engine.assume(len > 0);
                if (this.closed) {
                    throw new IOException("Stream closed");
                }
                if (this.data == null) {
                    _initBuffer();
                }
                Engine.assume(this.dataSize >= 0);
                result = _moveDataTo(b, 0, len);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::read(SymbolicInputStream, array<byte>, int, int) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:202
     */
    public int read(byte[] b, int off, int len) throws java.io.IOException {
        int result = 0;
        /* body */ {
            _checkFromIndexSize(off, len, b.length);
            if (len == 0) {
                result = 0;
            } else {
                if (this.closed) {
                    throw new IOException("Stream closed");
                }
                if (this.data == null) {
                    _initBuffer();
                }
                Engine.assume(this.dataSize >= 0);
                result = _moveDataTo(b, off, len);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::readAllBytes(SymbolicInputStream) -> array<byte>
     * Source: libsl/utils/SymbolicInputStream.main.lsl:218
     */
    public byte[] readAllBytes() throws java.io.IOException {
        byte[] result = null;
        /* body */ {
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            if (this.pos == 0) {
                result = this.data;
                _updatePosition(this.dataSize);
            } else {
                if (this.pos == this.dataSize) {
                    result = new byte[0];
                } else {
                    final int len = this.dataSize - this.pos;
                    Engine.assume(len > 0);
                    result = new byte[len];
                    _moveDataTo(result, 0, len);
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::readNBytes(SymbolicInputStream, array<byte>, int, int) -> int
     * Source: libsl/utils/SymbolicInputStream.main.lsl:243
     */
    public int readNBytes(byte[] b, int off, int len) throws java.io.IOException {
        int result = 0;
        /* body */ {
            _checkFromIndexSize(off, len, b.length);
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            if (len == 0) {
                result = 0;
            } else {
                result = _moveDataTo(b, off, len);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::readNBytes(SymbolicInputStream, int) -> array<byte>
     * Source: libsl/utils/SymbolicInputStream.main.lsl:256
     */
    public byte[] readNBytes(int len) throws java.io.IOException {
        byte[] result = null;
        /* body */ {
            if (len < 0) {
                throw new IllegalArgumentException("len < 0");
            }
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            if (len == 0) {
                result = new byte[0];
            } else {
                result = new byte[len];
                _moveDataTo(result, 0, len);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::reset(SymbolicInputStream) -> void
     * Source: libsl/utils/SymbolicInputStream.main.lsl:275
     */
    public void reset() throws java.io.IOException {
        /* body */ {
            if (this.supportMarks) {
                if (this.closed) {
                    throw new IOException("Stream closed");
                }
                if (this.data == null) {
                    _initBuffer();
                }
                Engine.assume(this.dataSize >= 0);
                if (this.markPos < 0) {
                    throw new IOException("Resetting to invalid mark");
                }
                this.pos = this.markPos;
            } else {
                throw new IOException("mark/reset not supported");
            }
        }
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::skip(SymbolicInputStream, long) -> long
     * Source: libsl/utils/SymbolicInputStream.main.lsl:294
     */
    public long skip(long n) throws java.io.IOException {
        long result = 0L;
        /* body */ {
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            result = 0L;
        }
        return result;
    }

    /**
     * [FUNCTION] SymbolicInputStreamAutomaton::transferTo(SymbolicInputStream, OutputStream) -> long
     * Source: libsl/utils/SymbolicInputStream.main.lsl:302
     */
    public long transferTo(OutputStream out) throws java.io.IOException {
        long result = 0L;
        /* body */ {
            if (out == null) {
                throw new NullPointerException();
            }
            if (this.closed) {
                throw new IOException("Stream closed");
            }
            if (this.data == null) {
                _initBuffer();
            }
            Engine.assume(this.dataSize >= 0);
            result = 0L;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(SymbolicInputStream.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
