// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.lang;

import generated.runtime.LibSLGlobals;
import java.io.Serializable;
import java.lang.CharSequence;
import java.lang.Comparable;
import java.lang.IllegalArgumentException;
import java.lang.IndexOutOfBoundsException;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.String;
import java.lang.StringIndexOutOfBoundsException;
import java.lang.Void;
import java.util.stream.IntStream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * StringBufferAutomaton for StringBuffer ~> java.lang.StringBuffer
 */
@Approximate(java.lang.StringBuffer.class)
public final class StringBuffer implements LibSLRuntime.Automaton, Serializable, Comparable<StringBuffer>, CharSequence {
    private static final long serialVersionUID = 3388685877147921107L;

    static {
        Engine.assume(true);
    }

    private byte __$lsl_state = __$lsl_States.Allocated;

    public String storage;

    public int length;

    @LibSLRuntime.AutomatonConstructor
    public StringBuffer(Void __$lsl_token, final byte p0, final String p1, final int p2) {
        this.__$lsl_state = p0;
        this.storage = p1;
        this.length = p2;
    }

    @LibSLRuntime.AutomatonConstructor
    public StringBuffer(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Allocated, "", 0);
    }

    /**
     * [CONSTRUCTOR] StringBufferAutomaton::StringBuffer(StringBuffer) -> StringBuffer
     */
    public StringBuffer() {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBufferAutomaton::StringBuffer(StringBuffer, CharSequence) -> StringBuffer
     */
    public StringBuffer(CharSequence seq) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
            if (seq == null) {
                throw new NullPointerException();
            }
            _appendCharSequence(seq);
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBufferAutomaton::StringBuffer(StringBuffer, String) -> StringBuffer
     */
    public StringBuffer(String str) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
            if (str == null) {
                throw new NullPointerException();
            }
            _appendString(str);
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBufferAutomaton::StringBuffer(StringBuffer, int) -> StringBuffer
     */
    public StringBuffer(int capacity) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_checkRange(int, int, int) -> void
     */
    private void _checkRange(int start, int end, int len) {
        /* body */ {
            if ((start < 0) || (start > end) || (end > len)) {
                throw new IndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_checkRangeSIOOBE(int, int, int) -> void
     */
    private void _checkRangeSIOOBE(int start, int end, int len) {
        /* body */ {
            if ((start < 0) || (start > end) || (end > len)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_checkIndex(int) -> void
     */
    private void _checkIndex(int index) {
        /* body */ {
            if ((index < 0) || (index >= this.length)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_checkOffset(int) -> void
     */
    private void _checkOffset(int offset) {
        /* body */ {
            if ((offset < 0) || (offset > this.length)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_isBmpCodePoint(int) -> boolean
     */
    private boolean _isBmpCodePoint(int codePoint) {
        boolean result = false;
        /* body */ {
            result = (codePoint >>> 16) == 0;
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_isValidCodePoint(int) -> boolean
     */
    private boolean _isValidCodePoint(int codePoint) {
        boolean result = false;
        /* body */ {
            result = (codePoint >= LibSLGlobals.MIN_CODE_POINT) && (codePoint <= LibSLGlobals.MAX_CODE_POINT);
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_lowSurrogate(int) -> char
     */
    private char _lowSurrogate(int codePoint) {
        char result = '?';
        /* body */ {
            result = ((char) ((codePoint & 1023) + LibSLGlobals.MIN_LOW_SURROGATE));
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_highSurrogate(int) -> char
     */
    private char _highSurrogate(int codePoint) {
        char result = '?';
        /* body */ {
            result = ((char) ((codePoint >>> 10) + (LibSLGlobals.MIN_HIGH_SURROGATE - (LibSLGlobals.MIN_SUPPLEMENTARY_CODE_POINT >>> 10))));
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_appendCharSequence(CharSequence) -> void
     */
    private void _appendCharSequence(CharSequence seq) {
        /* body */ {
            if (seq == null) {
                this.storage = this.storage.concat(LibSLRuntime.toString("null"));
                this.length += 4;
            } else {
                final int seqLength = seq.length();
                this.length += seqLength;
                int i = 0;
                for (i = 0; i < seqLength; i += 1) {
                    char currentChar = seq.charAt(i);
                    this.storage = this.storage.concat(LibSLRuntime.toString(currentChar));
                }
                ;
            }
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_appendString(String) -> void
     */
    private void _appendString(String str) {
        /* body */ {
            if (str == null) {
                str = "null";
                this.length += 4;
            } else {
                this.length += str.length();
            }
            this.storage = this.storage.concat(str);
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_delete(int, int) -> void
     */
    private void _delete(int start, int end) {
        /* body */ {
            final int len = (this.length - end) + start;
            char[] newStr = new char[len];
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < start; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = end; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length = len;
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_insertCharSequence(int, CharSequence, int, int, int) -> void
     */
    private void _insertCharSequence(int dstOffset, CharSequence s, int len, int start, int end) {
        /* body */ {
            _checkRange(start, end, len);
            final int countInsertedElements = end - start;
            final char[] newStr = new char[this.length + countInsertedElements];
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < dstOffset; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = start; i < end; i += 1) {
                newStr[arrayIndex] = s.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = dstOffset; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length += countInsertedElements;
        }
    }

    /**
     * [SUBROUTINE] StringBufferAutomaton::_substring(int, int) -> String
     */
    private String _substring(int start, int end) {
        String result = null;
        /* body */ {
            _checkRangeSIOOBE(start, end, this.length);
            final int sizeNewString = end - start;
            final char[] newStr = new char[sizeNewString];
            int i = 0;
            for (i = start; i < end; i += 1) {
                newStr[i] = this.storage.charAt(i);
            }
            ;
            result = LibSLRuntime.toString(newStr);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, CharSequence) -> StringBuffer
     */
    public synchronized StringBuffer append(CharSequence seq) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _appendCharSequence(seq);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, CharSequence, int, int) -> StringBuffer
     */
    public synchronized StringBuffer append(CharSequence seq, int start, int end) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            int seqLength = 4;
            if (seq == null) {
                seq = "null";
            }
            seqLength = seq.length();
            _checkRange(start, end, seqLength);
            this.length += end - start;
            int i = 0;
            for (i = start; i < end; i += 1) {
                char currentChar = seq.charAt(i);
                this.storage = this.storage.concat(LibSLRuntime.toString(currentChar));
            }
            ;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, Object) -> StringBuffer
     */
    public synchronized StringBuffer append(Object obj) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (obj == null) {
                this.storage = this.storage.concat("null");
                this.length += 4;
            } else {
                final String objString = LibSLRuntime.toString(obj);
                this.storage = this.storage.concat(objString);
                this.length += objString.length();
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, String) -> StringBuffer
     */
    public synchronized StringBuffer append(String str) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _appendString(str);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, StringBuffer) -> StringBuffer
     */
    public synchronized StringBuffer append(StringBuffer sb) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (sb == null) {
                this.storage = this.storage.concat("null");
                this.length += 4;
            } else {
                if ((sb != null && sb.getClass() == StringBuffer.class)) {
                    this.storage = this.storage.concat(((StringBuffer) sb).storage);
                    this.length += ((StringBuffer) sb).length;
                }
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, boolean) -> StringBuffer
     */
    public synchronized StringBuffer append(boolean b) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (b) {
                this.storage = this.storage.concat("true");
                this.length += 4;
            } else {
                this.storage = this.storage.concat("false");
                this.length += 5;
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, char) -> StringBuffer
     */
    public synchronized StringBuffer append(char c) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.storage = this.storage.concat(LibSLRuntime.toString(c));
            this.length += 1;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, array<char>) -> StringBuffer
     */
    public synchronized StringBuffer append(char[] str) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int strSize = str.length;
            this.length += strSize;
            this.storage = this.storage.concat(LibSLRuntime.toString(str));
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, array<char>, int, int) -> StringBuffer
     */
    public synchronized StringBuffer append(char[] str, int offset, int len) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int end = offset + len;
            final int strSize = str.length;
            _checkRange(offset, end, strSize);
            final char[] subArray = new char[len];
            int arrayIndex = 0;
            int i = 0;
            for (i = offset; i < end; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            this.length += len;
            this.storage = this.storage.concat(LibSLRuntime.toString(subArray));
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, double) -> StringBuffer
     */
    public synchronized StringBuffer append(double d) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String dString = LibSLRuntime.toString(d);
            this.storage = this.storage.concat(dString);
            this.length += dString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, float) -> StringBuffer
     */
    public synchronized StringBuffer append(float f) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String fString = LibSLRuntime.toString(f);
            this.storage = this.storage.concat(fString);
            this.length += fString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, int) -> StringBuffer
     */
    public synchronized StringBuffer append(int i) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String iString = LibSLRuntime.toString(i);
            this.storage = this.storage.concat(iString);
            this.length += iString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::append(StringBuffer, long) -> StringBuffer
     */
    public synchronized StringBuffer append(long lng) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String lngString = LibSLRuntime.toString(lng);
            this.storage = this.storage.concat(lngString);
            this.length += lngString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::appendCodePoint(StringBuffer, int) -> StringBuffer
     */
    public synchronized StringBuffer appendCodePoint(int codePoint) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (_isBmpCodePoint(codePoint)) {
                final char curChar = ((char) codePoint);
                this.storage = this.storage.concat(LibSLRuntime.toString(curChar));
                this.length += 1;
            } else {
                if (_isValidCodePoint(codePoint)) {
                    final char[] charsArray = new char[2];
                    charsArray[0] = _lowSurrogate(codePoint);
                    charsArray[1] = _highSurrogate(codePoint);
                    this.storage = this.storage.concat(LibSLRuntime.toString(charsArray));
                    this.length += 2;
                } else {
                    throw new IllegalArgumentException();
                }
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::capacity(StringBuffer) -> int
     */
    public synchronized int capacity() {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.length;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::charAt(StringBuffer, int) -> char
     */
    public synchronized char charAt(int index) {
        char result = '?';
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            result = this.storage.charAt(index);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::chars(StringBuffer) -> IntStream
     */
    public IntStream chars() {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::codePointAt(StringBuffer, int) -> int
     */
    public synchronized int codePointAt(int index) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            final int codePoint = Engine.makeSymbolicInt();
            Engine.assume(codePoint >= LibSLGlobals.MIN_CODE_POINT);
            Engine.assume(codePoint <= LibSLGlobals.MAX_CODE_POINT);
            result = codePoint;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::codePointBefore(StringBuffer, int) -> int
     */
    public synchronized int codePointBefore(int index) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            index -= 1;
            _checkIndex(index);
            final int codePoint = Engine.makeSymbolicInt();
            Engine.assume(codePoint >= LibSLGlobals.MIN_CODE_POINT);
            Engine.assume(codePoint <= LibSLGlobals.MAX_CODE_POINT);
            result = codePoint;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::codePointCount(StringBuffer, int, int) -> int
     */
    public synchronized int codePointCount(int beginIndex, int endIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if ((beginIndex < 0) || (endIndex > this.length) || (beginIndex > endIndex)) {
                throw new IndexOutOfBoundsException();
            }
            final int codePoint = Engine.makeSymbolicInt();
            final int leftBorder = endIndex - beginIndex;
            final int rightBorder = (endIndex - beginIndex) * 2;
            Engine.assume(codePoint >= leftBorder);
            Engine.assume(codePoint <= rightBorder);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::codePoints(StringBuffer) -> IntStream
     */
    public IntStream codePoints() {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::compareTo(StringBuffer, StringBuffer) -> int
     */
    public synchronized int compareTo(StringBuffer another) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (another == this) {
                result = 0;
            } else {
                final String anotherString = ((StringBuffer) another).storage;
                result = this.storage.compareTo(anotherString);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::delete(StringBuffer, int, int) -> StringBuffer
     */
    public synchronized StringBuffer delete(int start, int end) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (end > this.length) {
                end = this.length;
            }
            _checkRangeSIOOBE(start, end, this.length);
            _delete(start, end);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::deleteCharAt(StringBuffer, int) -> StringBuffer
     */
    public synchronized StringBuffer deleteCharAt(int index) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            _delete(index, index + 1);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::ensureCapacity(StringBuffer, int) -> void
     */
    public synchronized void ensureCapacity(int minimumCapacity) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            Engine.assume(true);
        }
    }

    /**
     * [FUNCTION] StringBufferAutomaton::getChars(StringBuffer, int, int, array<char>, int) -> void
     */
    public synchronized void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkRangeSIOOBE(srcBegin, srcEnd, this.length);
            int n = srcEnd - srcBegin;
            final int dstLength = dst.length;
            _checkRange(dstBegin, dstBegin + n, dstLength);
            char[] storageChars = this.storage.toCharArray();
            int i = 0;
            for (i = srcBegin; i < srcEnd; i += 1) {
                dst[dstBegin] = storageChars[i];
                dstBegin += 1;
            }
            ;
        }
    }

    /**
     * [FUNCTION] StringBufferAutomaton::indexOf(StringBuffer, String) -> int
     */
    public int indexOf(String str) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.indexOf(str, 0);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::indexOf(StringBuffer, String, int) -> int
     */
    public synchronized int indexOf(String str, int fromIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.indexOf(str, fromIndex);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, CharSequence) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, CharSequence s) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, CharSequence, int, int) -> StringBuffer
     */
    public synchronized StringBuffer insert(int dstOffset, CharSequence s, int start, int end) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, start, end);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, Object) -> StringBuffer
     */
    public synchronized StringBuffer insert(int dstOffset, Object obj) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = "null";
            int len = 4;
            if (obj != null) {
                s = LibSLRuntime.toString(obj);
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, String) -> StringBuffer
     */
    public synchronized StringBuffer insert(int dstOffset, String s) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, boolean) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, boolean b) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = "false";
            int len = 5;
            if (b) {
                s = "true";
                len = 4;
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, char) -> StringBuffer
     */
    public synchronized StringBuffer insert(int dstOffset, char c) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            final char[] subArray = new char[this.length + 1];
            final char[] str = this.storage.toCharArray();
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < dstOffset; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            subArray[i] = c;
            arrayIndex += 1;
            for (i = dstOffset; i < this.length; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(subArray);
            this.length += 1;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, array<char>) -> StringBuffer
     */
    public synchronized StringBuffer insert(int dstOffset, char[] str) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            final String s = LibSLRuntime.toString(str);
            final int len = str.length;
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, array<char>, int, int) -> StringBuffer
     */
    public synchronized StringBuffer insert(int index, char[] str, int offset, int len) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(index);
            final int lenStr = str.length;
            _checkRangeSIOOBE(offset, offset + len, lenStr);
            final String s = LibSLRuntime.toString(str);
            _insertCharSequence(index, s, len, offset, offset + len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, double) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, double d) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(d);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, float) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, float f) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(f);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, int) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, int ii) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(ii);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::insert(StringBuffer, int, long) -> StringBuffer
     */
    public StringBuffer insert(int dstOffset, long l) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(l);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::lastIndexOf(StringBuffer, String) -> int
     */
    public int lastIndexOf(String str) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.lastIndexOf(str);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::lastIndexOf(StringBuffer, String, int) -> int
     */
    public synchronized int lastIndexOf(String str, int fromIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.lastIndexOf(str, fromIndex);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::length(StringBuffer) -> int
     */
    public synchronized int length() {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.length;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::offsetByCodePoints(StringBuffer, int, int) -> int
     */
    public synchronized int offsetByCodePoints(int index, int codePointOffset) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            result = Character.offsetByCodePoints(this.storage, index, codePointOffset);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::replace(StringBuffer, int, int, String) -> StringBuffer
     */
    public synchronized StringBuffer replace(int start, int end, String s) {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (end > this.length) {
                end = this.length;
            }
            _checkRangeSIOOBE(start, end, this.length);
            final int strLength = s.length();
            final int newLength = (this.length + strLength) - (end - start);
            final char[] newStr = new char[newLength];
            int arrayIndex = 0;
            int i = 0;
            for (i = 0; i < start; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = 0; i < strLength; i += 1) {
                newStr[arrayIndex] = s.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = end; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length = newLength;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::reverse(StringBuffer) -> StringBuffer
     */
    public synchronized StringBuffer reverse() {
        StringBuffer result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                final char[] oldStorage = this.storage.toCharArray();
                final char[] newStorage = new char[this.length];
                Engine.assume(newStorage.length == this.length);
                Engine.assume(oldStorage.length == newStorage.length);
                int j = this.length - 1;
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    newStorage[j] = oldStorage[i];
                    j -= 1;
                }
                ;
                this.storage = LibSLRuntime.toString(newStorage);
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::setCharAt(StringBuffer, int, char) -> void
     */
    public synchronized void setCharAt(int index, char ch) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            final char[] newStr = new char[this.length];
            int arrayIndex = 0;
            int i = 0;
            for (i = 0; i < index; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            newStr[index] = ch;
            for (i = index + 1; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
        }
    }

    /**
     * [FUNCTION] StringBufferAutomaton::setLength(StringBuffer, int) -> void
     */
    public synchronized void setLength(int newLength) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (newLength < 0) {
                throw new StringIndexOutOfBoundsException();
            } else {
                if (newLength == 0) {
                    this.storage = "";
                    this.length = 0;
                } else {
                    int i = 0;
                    final char[] newStr = new char[newLength];
                    if (newLength > this.length) {
                        for (i = 0; i < this.length; i += 1) {
                            newStr[i] = this.storage.charAt(i);
                        }
                        ;
                        for (i = this.length; i < newLength; i += 1) {
                            newStr[i] = 0;
                        }
                        ;
                    } else {
                        for (i = 0; i < newLength; i += 1) {
                            newStr[i] = this.storage.charAt(i);
                        }
                        ;
                    }
                    this.storage = LibSLRuntime.toString(newStr);
                    this.length = newLength;
                }
            }
        }
    }

    /**
     * [FUNCTION] StringBufferAutomaton::subSequence(StringBuffer, int, int) -> CharSequence
     */
    public synchronized CharSequence subSequence(int start, int end) {
        CharSequence result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, end);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::substring(StringBuffer, int) -> String
     */
    public synchronized String substring(int start) {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, this.length);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::substring(StringBuffer, int, int) -> String
     */
    public synchronized String substring(int start, int end) {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, end);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::toString(StringBuffer) -> String
     */
    public synchronized String toString() {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBufferAutomaton::trimToSize(StringBuffer) -> void
     */
    public synchronized void trimToSize() {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            Engine.assume(true);
        }
    }

    public static final class __$lsl_States {
        public static final byte Allocated = (byte) 0;

        public static final byte Initialized = (byte) 1;
    }

    @Approximate(StringBuffer.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
