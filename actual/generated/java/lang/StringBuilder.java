// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.lang;

import generated.runtime.LibSLGlobals;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.lang.CharSequence;
import java.lang.Comparable;
import java.lang.IllegalArgumentException;
import java.lang.IndexOutOfBoundsException;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.String;
import java.lang.StringIndexOutOfBoundsException;
import java.lang.Void;
import java.util.stream.IntStream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * StringBuilderAutomaton for StringBuilder ~> java.lang.StringBuilder
 */
@Approximate(java.lang.StringBuilder.class)
public final class StringBuilder implements LibSLRuntime.Automaton, Serializable, Comparable<StringBuilder>, CharSequence {
    private static final long serialVersionUID = 4383685877147921099L;

    static {
        Engine.assume(true);
    }

    private byte __$lsl_state = __$lsl_States.Allocated;

    public String storage;

    public int length;

    @LibSLRuntime.AutomatonConstructor
    public StringBuilder(Void __$lsl_token, final byte p0, final String p1, final int p2) {
        this.__$lsl_state = p0;
        this.storage = p1;
        this.length = p2;
    }

    @LibSLRuntime.AutomatonConstructor
    public StringBuilder(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Allocated, "", 0);
    }

    /**
     * [CONSTRUCTOR] StringBuilderAutomaton::StringBuilder(StringBuilder) -> StringBuilder
     */
    public StringBuilder() {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBuilderAutomaton::StringBuilder(StringBuilder, CharSequence) -> StringBuilder
     */
    public StringBuilder(CharSequence seq) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
            if (seq == null) {
                throw new NullPointerException();
            }
            _appendCharSequence(seq);
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBuilderAutomaton::StringBuilder(StringBuilder, String) -> StringBuilder
     */
    public StringBuilder(String str) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
            if (str == null) {
                throw new NullPointerException();
            }
            _appendString(str);
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [CONSTRUCTOR] StringBuilderAutomaton::StringBuilder(StringBuilder, int) -> StringBuilder
     */
    public StringBuilder(int capacity) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_checkRange(int, int, int) -> void
     */
    private void _checkRange(int start, int end, int len) {
        /* body */ {
            if ((start < 0) || (start > end) || (end > len)) {
                throw new IndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_checkRangeSIOOBE(int, int, int) -> void
     */
    private void _checkRangeSIOOBE(int start, int end, int len) {
        /* body */ {
            if ((start < 0) || (start > end) || (end > len)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_checkIndex(int) -> void
     */
    private void _checkIndex(int index) {
        /* body */ {
            if ((index < 0) || (index >= this.length)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_checkOffset(int) -> void
     */
    private void _checkOffset(int offset) {
        /* body */ {
            if ((offset < 0) || (offset > this.length)) {
                throw new StringIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_isBmpCodePoint(int) -> boolean
     */
    private boolean _isBmpCodePoint(int codePoint) {
        boolean result = false;
        /* body */ {
            result = (codePoint >>> 16) == 0;
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_isValidCodePoint(int) -> boolean
     */
    private boolean _isValidCodePoint(int codePoint) {
        boolean result = false;
        /* body */ {
            result = (codePoint >= LibSLGlobals.MIN_CODE_POINT) && (codePoint <= LibSLGlobals.MAX_CODE_POINT);
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_lowSurrogate(int) -> char
     */
    private char _lowSurrogate(int codePoint) {
        char result = '?';
        /* body */ {
            result = ((char) ((codePoint & 1023) + LibSLGlobals.MIN_LOW_SURROGATE));
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_highSurrogate(int) -> char
     */
    private char _highSurrogate(int codePoint) {
        char result = '?';
        /* body */ {
            result = ((char) ((codePoint >>> 10) + (LibSLGlobals.MIN_HIGH_SURROGATE - (LibSLGlobals.MIN_SUPPLEMENTARY_CODE_POINT >>> 10))));
        }
        return result;
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_appendCharSequence(CharSequence) -> void
     */
    private void _appendCharSequence(CharSequence seq) {
        /* body */ {
            if (seq == null) {
                this.storage = this.storage.concat(LibSLRuntime.toString("null"));
                this.length += 4;
            } else {
                final int seqLength = seq.length();
                this.length += seqLength;
                int i = 0;
                for (i = 0; i < seqLength; i += 1) {
                    char currentChar = seq.charAt(i);
                    this.storage = this.storage.concat(LibSLRuntime.toString(currentChar));
                }
                ;
            }
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_appendString(String) -> void
     */
    private void _appendString(String str) {
        /* body */ {
            if (str == null) {
                str = "null";
                this.length += 4;
            } else {
                this.length += str.length();
            }
            this.storage = this.storage.concat(str);
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_delete(int, int) -> void
     */
    private void _delete(int start, int end) {
        /* body */ {
            final int len = (this.length - end) + start;
            char[] newStr = new char[len];
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < start; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = end; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length = len;
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_insertCharSequence(int, CharSequence, int, int, int) -> void
     */
    private void _insertCharSequence(int dstOffset, CharSequence s, int len, int start, int end) {
        /* body */ {
            _checkRange(start, end, len);
            final int countInsertedElements = end - start;
            final char[] newStr = new char[this.length + countInsertedElements];
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < dstOffset; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = start; i < end; i += 1) {
                newStr[arrayIndex] = s.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = dstOffset; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length += countInsertedElements;
        }
    }

    /**
     * [SUBROUTINE] StringBuilderAutomaton::_substring(int, int) -> String
     */
    private String _substring(int start, int end) {
        String result = null;
        /* body */ {
            _checkRangeSIOOBE(start, end, this.length);
            final int sizeNewString = end - start;
            final char[] newStr = new char[sizeNewString];
            int i = 0;
            for (i = start; i < end; i += 1) {
                newStr[i] = this.storage.charAt(i);
            }
            ;
            result = LibSLRuntime.toString(newStr);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, CharSequence) -> StringBuilder
     */
    public StringBuilder append(CharSequence seq) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _appendCharSequence(seq);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, CharSequence, int, int) -> StringBuilder
     */
    public StringBuilder append(CharSequence seq, int start, int end) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            int seqLength = 4;
            if (seq == null) {
                seq = "null";
            }
            seqLength = seq.length();
            _checkRange(start, end, seqLength);
            this.length += end - start;
            int i = 0;
            for (i = start; i < end; i += 1) {
                char currentChar = seq.charAt(i);
                this.storage = this.storage.concat(LibSLRuntime.toString(currentChar));
            }
            ;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, Object) -> StringBuilder
     */
    public StringBuilder append(Object obj) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (obj == null) {
                this.storage = this.storage.concat("null");
                this.length += 4;
            } else {
                final String objString = LibSLRuntime.toString(obj);
                this.storage = this.storage.concat(objString);
                this.length += objString.length();
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, String) -> StringBuilder
     */
    public StringBuilder append(String str) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _appendString(str);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, StringBuffer) -> StringBuilder
     */
    public StringBuilder append(StringBuffer sb) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (sb == null) {
                this.storage = this.storage.concat("null");
                this.length += 4;
            } else {
                this.storage = this.storage.concat(LibSLRuntime.toString(sb));
                this.length = this.storage.length();
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, boolean) -> StringBuilder
     */
    public StringBuilder append(boolean b) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (b) {
                this.storage = this.storage.concat("true");
                this.length += 4;
            } else {
                this.storage = this.storage.concat("false");
                this.length += 5;
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, char) -> StringBuilder
     */
    public StringBuilder append(char c) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.storage = this.storage.concat(LibSLRuntime.toString(c));
            this.length += 1;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, array<char>) -> StringBuilder
     */
    public StringBuilder append(char[] str) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int strSize = str.length;
            this.length += strSize;
            this.storage = this.storage.concat(LibSLRuntime.toString(str));
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, array<char>, int, int) -> StringBuilder
     */
    public StringBuilder append(char[] str, int offset, int len) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int end = offset + len;
            final int strSize = str.length;
            _checkRange(offset, end, strSize);
            final char[] subArray = new char[len];
            int arrayIndex = 0;
            int i = 0;
            for (i = offset; i < end; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            this.length += len;
            this.storage = this.storage.concat(LibSLRuntime.toString(subArray));
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, double) -> StringBuilder
     */
    public StringBuilder append(double d) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String dString = LibSLRuntime.toString(d);
            this.storage = this.storage.concat(dString);
            this.length += dString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, float) -> StringBuilder
     */
    public StringBuilder append(float f) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String fString = LibSLRuntime.toString(f);
            this.storage = this.storage.concat(fString);
            this.length += fString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, int) -> StringBuilder
     */
    public StringBuilder append(int i) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String iString = LibSLRuntime.toString(i);
            this.storage = this.storage.concat(iString);
            this.length += iString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::append(StringBuilder, long) -> StringBuilder
     */
    public StringBuilder append(long lng) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final String lngString = LibSLRuntime.toString(lng);
            this.storage = this.storage.concat(lngString);
            this.length += lngString.length();
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::appendCodePoint(StringBuilder, int) -> StringBuilder
     */
    public StringBuilder appendCodePoint(int codePoint) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (_isBmpCodePoint(codePoint)) {
                final char curChar = ((char) codePoint);
                this.storage = this.storage.concat(LibSLRuntime.toString(curChar));
                this.length += 1;
            } else {
                if (_isValidCodePoint(codePoint)) {
                    final char[] charsArray = new char[2];
                    charsArray[0] = _lowSurrogate(codePoint);
                    charsArray[1] = _highSurrogate(codePoint);
                    this.storage = this.storage.concat(LibSLRuntime.toString(charsArray));
                    this.length += 2;
                } else {
                    throw new IllegalArgumentException();
                }
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::compareTo(StringBuilder, StringBuilder) -> int
     */
    public int compareTo(StringBuilder another) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (another == this) {
                result = 0;
            } else {
                final String anotherString = ((StringBuilder) another).storage;
                result = this.storage.compareTo(anotherString);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::delete(StringBuilder, int, int) -> StringBuilder
     */
    public StringBuilder delete(int start, int end) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (end > this.length) {
                end = this.length;
            }
            _checkRangeSIOOBE(start, end, this.length);
            _delete(start, end);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::deleteCharAt(StringBuilder, int) -> StringBuilder
     */
    public StringBuilder deleteCharAt(int index) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            _delete(index, index + 1);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::indexOf(StringBuilder, String) -> int
     */
    public int indexOf(String str) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.indexOf(str, 0);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::indexOf(StringBuilder, String, int) -> int
     */
    public int indexOf(String str, int fromIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.indexOf(str, fromIndex);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, CharSequence) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, CharSequence s) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, CharSequence, int, int) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, CharSequence s, int start, int end) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, start, end);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, Object) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, Object obj) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = "null";
            int len = 4;
            if (obj != null) {
                s = LibSLRuntime.toString(obj);
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, String) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, String s) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            int len = 4;
            if (s == null) {
                s = "null";
            } else {
                len = s.length();
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, boolean) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, boolean b) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = "false";
            int len = 5;
            if (b) {
                s = "true";
                len = 4;
            }
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, char) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, char c) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            final char[] subArray = new char[this.length + 1];
            final char[] str = this.storage.toCharArray();
            int i = 0;
            int arrayIndex = 0;
            for (i = 0; i < dstOffset; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            subArray[i] = c;
            arrayIndex += 1;
            for (i = dstOffset; i < this.length; i += 1) {
                subArray[arrayIndex] = str[i];
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(subArray);
            this.length += 1;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, array<char>) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, char[] str) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            final String s = LibSLRuntime.toString(str);
            final int len = str.length;
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, array<char>, int, int) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, char[] str, int start, int end) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            final String s = LibSLRuntime.toString(str);
            final int len = str.length;
            _checkRangeSIOOBE(start, start + end, len);
            _insertCharSequence(dstOffset, s, len, start, end);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, double) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, double d) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(d);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, float) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, float f) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(f);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, int) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, int ii) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(ii);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::insert(StringBuilder, int, long) -> StringBuilder
     */
    public StringBuilder insert(int dstOffset, long l) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkOffset(dstOffset);
            String s = LibSLRuntime.toString(l);
            int len = s.length();
            _insertCharSequence(dstOffset, s, len, 0, len);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::lastIndexOf(StringBuilder, String) -> int
     */
    public int lastIndexOf(String str) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.lastIndexOf(str);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::lastIndexOf(StringBuilder, String, int) -> int
     */
    public int lastIndexOf(String str, int fromIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage.lastIndexOf(str, fromIndex);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::replace(StringBuilder, int, int, String) -> StringBuilder
     */
    public StringBuilder replace(int start, int end, String s) {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (end > this.length) {
                end = this.length;
            }
            _checkRangeSIOOBE(start, end, this.length);
            final int strLength = s.length();
            final int newLength = (this.length + strLength) - (end - start);
            final char[] newStr = new char[newLength];
            int arrayIndex = 0;
            int i = 0;
            for (i = 0; i < start; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = 0; i < strLength; i += 1) {
                newStr[arrayIndex] = s.charAt(i);
                arrayIndex += 1;
            }
            ;
            for (i = end; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
            this.length = newLength;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::reverse(StringBuilder) -> StringBuilder
     */
    public StringBuilder reverse() {
        StringBuilder result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                final char[] oldStorage = this.storage.toCharArray();
                final char[] newStorage = new char[this.length];
                Engine.assume(newStorage.length == this.length);
                Engine.assume(oldStorage.length == newStorage.length);
                int j = this.length - 1;
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    newStorage[j] = oldStorage[i];
                    j -= 1;
                }
                ;
                this.storage = LibSLRuntime.toString(newStorage);
            }
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::toString(StringBuilder) -> String
     */
    public String toString() {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storage;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::capacity(StringBuilder) -> int
     */
    public int capacity() {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.length;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::ensureCapacity(StringBuilder, int) -> void
     */
    public void ensureCapacity(int minimumCapacity) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            Engine.assume(true);
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::length(StringBuilder) -> int
     */
    public int length() {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.length;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::charAt(StringBuilder, int) -> char
     */
    public char charAt(int index) {
        char result = '?';
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            result = this.storage.charAt(index);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::setLength(StringBuilder, int) -> void
     */
    public void setLength(int newLength) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (newLength < 0) {
                throw new StringIndexOutOfBoundsException();
            } else {
                if (newLength == 0) {
                    this.storage = "";
                    this.length = 0;
                } else {
                    int i = 0;
                    final char[] newStr = new char[newLength];
                    if (newLength > this.length) {
                        for (i = 0; i < this.length; i += 1) {
                            newStr[i] = this.storage.charAt(i);
                        }
                        ;
                        for (i = this.length; i < newLength; i += 1) {
                            newStr[i] = 0;
                        }
                        ;
                    } else {
                        for (i = 0; i < newLength; i += 1) {
                            newStr[i] = this.storage.charAt(i);
                        }
                        ;
                    }
                    this.storage = LibSLRuntime.toString(newStr);
                    this.length = newLength;
                }
            }
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::setCharAt(StringBuilder, int, char) -> void
     */
    public void setCharAt(int index, char ch) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            final char[] newStr = new char[this.length];
            int arrayIndex = 0;
            int i = 0;
            for (i = 0; i < index; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            newStr[index] = ch;
            for (i = index + 1; i < this.length; i += 1) {
                newStr[arrayIndex] = this.storage.charAt(i);
                arrayIndex += 1;
            }
            ;
            this.storage = LibSLRuntime.toString(newStr);
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::trimToSize(StringBuilder) -> void
     */
    public void trimToSize() {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            Engine.assume(true);
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::substring(StringBuilder, int) -> String
     */
    public String substring(int start) {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, this.length);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::substring(StringBuilder, int, int) -> String
     */
    public String substring(int start, int end) {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, end);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::subSequence(StringBuilder, int, int) -> CharSequence
     */
    public CharSequence subSequence(int start, int end) {
        CharSequence result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = _substring(start, end);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::getChars(StringBuilder, int, int, array<char>, int) -> void
     */
    public void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkRangeSIOOBE(srcBegin, srcEnd, this.length);
            int n = srcEnd - srcBegin;
            final int dstLength = dst.length;
            _checkRange(dstBegin, dstBegin + n, dstLength);
            char[] storageChars = this.storage.toCharArray();
            int i = 0;
            for (i = srcBegin; i < srcEnd; i += 1) {
                dst[dstBegin] = storageChars[i];
                dstBegin += 1;
            }
            ;
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::codePointCount(StringBuilder, int, int) -> int
     */
    public int codePointCount(int beginIndex, int endIndex) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if ((beginIndex < 0) || (endIndex > this.length) || (beginIndex > endIndex)) {
                throw new IndexOutOfBoundsException();
            }
            final int codePoint = Engine.makeSymbolicInt();
            final int leftBorder = endIndex - beginIndex;
            final int rightBorder = (endIndex - beginIndex) * 2;
            Engine.assume(codePoint >= leftBorder);
            Engine.assume(codePoint <= rightBorder);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::codePointAt(StringBuilder, int) -> int
     */
    public int codePointAt(int index) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            final int codePoint = Engine.makeSymbolicInt();
            Engine.assume(codePoint >= LibSLGlobals.MIN_CODE_POINT);
            Engine.assume(codePoint <= LibSLGlobals.MAX_CODE_POINT);
            result = codePoint;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::codePointBefore(StringBuilder, int) -> int
     */
    public int codePointBefore(int index) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            index -= 1;
            _checkIndex(index);
            final int codePoint = Engine.makeSymbolicInt();
            Engine.assume(codePoint >= LibSLGlobals.MIN_CODE_POINT);
            Engine.assume(codePoint <= LibSLGlobals.MAX_CODE_POINT);
            result = codePoint;
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::offsetByCodePoints(StringBuilder, int, int) -> int
     */
    public int offsetByCodePoints(int index, int codePointOffset) {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _checkIndex(index);
            result = Character.offsetByCodePoints(this.storage, index, codePointOffset);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::codePoints(StringBuilder) -> IntStream
     */
    public IntStream codePoints() {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::chars(StringBuilder) -> IntStream
     */
    public IntStream chars() {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
        }
        return result;
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::writeObject(StringBuilder, ObjectOutputStream) -> void
     */
    private void writeObject(ObjectOutputStream s) throws java.io.IOException {
        /* body */ {
            LibSLRuntime.not_implemented(/* no serialization support yet */);
        }
    }

    /**
     * [FUNCTION] StringBuilderAutomaton::readObject(StringBuilder, ObjectInputStream) -> void
     */
    private void readObject(ObjectInputStream s) throws java.io.IOException,
            java.lang.ClassNotFoundException {
        /* body */ {
            LibSLRuntime.not_implemented(/* no serialization support yet */);
        }
    }

    public static final class __$lsl_States {
        public static final byte Allocated = (byte) 0;

        public static final byte Initialized = (byte) 1;
    }

    @Approximate(StringBuilder.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
