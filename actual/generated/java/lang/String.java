// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - java/lang/String.lsl:145
//  - java/lang/String.patch.lsl:17
//
package generated.java.lang;

import java.io.Serializable;
import java.lang.Object;
import java.lang.StringIndexOutOfBoundsException;
import java.lang.SuppressWarnings;
import java.lang.Void;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * StringAutomaton for LSLString ~> java.lang.String
 */
@SuppressWarnings({"all", "unchecked"})
@Approximate(java.lang.String.class)
public class String implements LibSLRuntime.Automaton, Serializable {
    public byte[] value;

    public int length;

    @LibSLRuntime.AutomatonConstructor
    public String(Void __$lsl_token, final byte p0, final byte[] p1, final int p2) {
        this.value = p1;
        this.length = p2;
    }

    @LibSLRuntime.AutomatonConstructor
    public String(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, null, 0);
    }

    /**
     * [CONSTRUCTOR] StringAutomaton::<init>(LSLString) -> void
     * Source: java/lang/String.patch.lsl:70
     */
    public String() {
        this((Void) null);
        /* body */ {
            this.value = new byte[0];
            this.length = 0;
        }
    }

    /**
     * [CONSTRUCTOR] StringAutomaton::<init>(LSLString, String) -> void
     * Source: java/lang/String.patch.lsl:77
     */
    public String(java.lang.String original) {
        this((Void) null);
        /* body */ {
            this.value = ((String) ((Object) original)).value;
            this.length = this.value.length;
        }
    }

    /**
     * [CONSTRUCTOR] StringAutomaton::<init>(LSLString, array<byte>) -> void
     * Source: java/lang/String.patch.lsl:84
     */
    public String(byte[] bytes) {
        this((Void) null);
        /* body */ {
            final int len = bytes.length;
            this.length = len;
            this.value = new byte[len];
            LibSLRuntime.ArrayActions.copy(bytes, 0, this.value, 0, len);
        }
    }

    /**
     * [FUNCTION] StringAutomaton::copyValueOf(array<char>) -> String
     * Source: java/lang/String.patch.lsl:96
     */
    public static java.lang.String copyValueOf(char[] data) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(data);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::copyValueOf(array<char>, int, int) -> String
     * Source: java/lang/String.patch.lsl:102
     */
    public static java.lang.String copyValueOf(char[] data, int offset, int count) {
        java.lang.String result = null;
        /* body */ {
            final char[] segment = new char[count];
            LibSLRuntime.ArrayActions.copy(data, offset, segment, 0, count);
            result = LibSLRuntime.toString(segment);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(Object) -> String
     * Source: java/lang/String.patch.lsl:111
     */
    public static java.lang.String valueOf(Object x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(boolean) -> String
     * Source: java/lang/String.patch.lsl:117
     */
    public static java.lang.String valueOf(boolean x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(char) -> String
     * Source: java/lang/String.patch.lsl:123
     */
    public static java.lang.String valueOf(char x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(array<char>) -> String
     * Source: java/lang/String.patch.lsl:129
     */
    public static java.lang.String valueOf(char[] data) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(data);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(array<char>, int, int) -> String
     * Source: java/lang/String.patch.lsl:135
     */
    public static java.lang.String valueOf(char[] data, int offset, int count) {
        java.lang.String result = null;
        /* body */ {
            final char[] segment = new char[count];
            LibSLRuntime.ArrayActions.copy(data, offset, segment, 0, count);
            result = LibSLRuntime.toString(segment);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(double) -> String
     * Source: java/lang/String.patch.lsl:144
     */
    public static java.lang.String valueOf(double x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(float) -> String
     * Source: java/lang/String.patch.lsl:150
     */
    public static java.lang.String valueOf(float x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(int) -> String
     * Source: java/lang/String.patch.lsl:156
     */
    public static java.lang.String valueOf(int x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::valueOf(long) -> String
     * Source: java/lang/String.patch.lsl:162
     */
    public static java.lang.String valueOf(long x) {
        java.lang.String result = null;
        /* body */ {
            result = LibSLRuntime.toString(x);
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::concat(LSLString, String) -> String
     * Source: java/lang/String.patch.lsl:170
     */
    public java.lang.String concat(java.lang.String str) {
        java.lang.String result = null;
        /* body */ {
            Engine.assume(this.value != null);
            Engine.assume(this.value.length <= 50);
            Engine.assume(this.length == this.value.length);
            final byte[] otherVal = ((String) ((Object) str)).value;
            final int otherLen = otherVal.length;
            if (otherLen == 0) {
                result = ((java.lang.String) ((Object) this));
            } else {
                final int newLength = this.length + otherLen;
                final byte[] newValue = new byte[newLength];
                LibSLRuntime.ArrayActions.copy(this.value, 0, newValue, 0, this.length);
                LibSLRuntime.ArrayActions.copy(otherVal, 0, newValue, this.length, otherLen);
                result = (java.lang.String) ((Object) new String((Void) null, 
                    /* state = */ String.__$lsl_States.Initialized, 
                    /* value = */ newValue, 
                    /* length = */ newLength
                ));
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::getBytes(LSLString) -> array<byte>
     * Source: java/lang/String.patch.lsl:197
     */
    public byte[] getBytes() {
        byte[] result = null;
        /* body */ {
            Engine.assume(this.value != null);
            Engine.assume(this.value.length <= 50);
            Engine.assume(this.length == this.value.length);
            result = this.value;
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::getBytes(LSLString, int, int, array<byte>, int) -> void
     * Source: java/lang/String.patch.lsl:205
     */
    public void getBytes(int srcBegin, int srcEnd, byte[] dst, int dstBegin) {
        /* body */ {
            if (srcBegin < 0) {
                throw new StringIndexOutOfBoundsException(srcBegin);
            }
            if (this.length < srcEnd) {
                throw new StringIndexOutOfBoundsException(srcEnd);
            }
            final int count = srcEnd - srcBegin;
            if (count < 0) {
                throw new StringIndexOutOfBoundsException(count);
            }
            Engine.assume(this.value != null);
            Engine.assume(this.value.length <= 50);
            Engine.assume(this.length == this.value.length);
            LibSLRuntime.ArrayActions.copy(this.value, srcBegin, dst, dstBegin, count);
        }
    }

    /**
     * [FUNCTION] StringAutomaton::isEmpty(LSLString) -> boolean
     * Source: java/lang/String.patch.lsl:222
     */
    public boolean isEmpty() {
        boolean result = false;
        /* body */ {
            result = this.length == 0;
        }
        return result;
    }

    /**
     * [FUNCTION] StringAutomaton::length(LSLString) -> int
     * Source: java/lang/String.patch.lsl:228
     */
    public int length() {
        int result = 0;
        /* body */ {
            result = this.length;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(String.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
