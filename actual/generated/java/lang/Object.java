// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.lang;

import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * ObjectAutomaton for LSLObject ~> java.lang.Object
 */
@Approximate(java.lang.Object.class)
public class Object implements LibSLRuntime.Automaton {
    static {
        /* ObjectAutomaton::__clinit__() */ {
            ;
        }
    }

    @LibSLRuntime.AutomatonConstructor
    public Object(Void __$lsl_token, final byte p0) {
    }

    @LibSLRuntime.AutomatonConstructor
    public Object(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized);
    }

    /**
     * [FUNCTION] ObjectAutomaton::equals(LSLObject, Object) -> boolean
     */
    public boolean equals(java.lang.Object obj) {
        boolean result = false;
        /* body */ {
            result = this == obj;
        }
        return result;
    }

    /**
     * [FUNCTION] ObjectAutomaton::hashCode(LSLObject) -> int
     */
    public int hashCode() {
        int result = 0;
        /* body */ {
            result = Engine.makeSymbolicInt();
        }
        return result;
    }

    /**
     * [FUNCTION] ObjectAutomaton::toString(LSLObject) -> String
     */
    public String toString() {
        String result = null;
        /* body */ {
            result = Engine.makeSymbolic(String.class);
            Engine.assume(result != null);
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(Object.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
