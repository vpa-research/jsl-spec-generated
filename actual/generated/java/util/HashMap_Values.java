// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - java/util/HashMap.lsl:37
//  - java/util/HashMap.Values.lsl:25
//
package generated.java.util;

import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.String;
import java.lang.SuppressWarnings;
import java.lang.UnsupportedOperationException;
import java.lang.Void;
import java.util.Collection;
import java.util.Iterator;
import java.util.Map;
import java.util.Spliterator;
import java.util.function.Consumer;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.stream.Stream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;
import stub.java.util.stream.StreamLSL;

/**
 * HashMap_ValuesAutomaton for HashMap_Values ~> java.util.HashMap_Values
 */
@SuppressWarnings({"all", "unchecked"})
@Approximate(stub.java.util.HashMap_Values.class)
public class HashMap_Values implements LibSLRuntime.Automaton {
    static {
        Engine.assume(true);
    }

    private byte __$lsl_state = __$lsl_States.Allocated;

    public LibSLRuntime.Map<Object, Map.Entry<Object, Object>> storageRef;

    public HashMap parent;

    @LibSLRuntime.AutomatonConstructor
    public HashMap_Values(Void __$lsl_token, final byte p0,
            final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> p1, final HashMap p2) {
        this.__$lsl_state = p0;
        this.storageRef = p1;
        this.parent = p2;
    }

    @LibSLRuntime.AutomatonConstructor
    public HashMap_Values(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Allocated, null, null);
    }

    /**
     * [CONSTRUCTOR] HashMap_ValuesAutomaton::<init>(HashMap_Values, HashMap) -> void
     * Source: java/util/HashMap.Values.lsl:106
     */
    private HashMap_Values(HashMap _this) {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
            LibSLRuntime.error("Private constructor call");
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [SUBROUTINE] HashMap_ValuesAutomaton::_mapToValuesArray() -> array<Object>
     * Source: java/util/HashMap.Values.lsl:82
     */
    private Object[] _mapToValuesArray() {
        Object[] result = null;
        /* body */ {
            final int storageSize = this.storageRef.size();
            result = new Object[storageSize];
            final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
            int i = 0;
            for (i = 0; i < storageSize; i += 1) {
                final Object curKey = unseen.anyKey();
                final Map.Entry<Object, Object> entry = unseen.get(curKey);
                result[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                unseen.remove(curKey);
            }
            ;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::add(HashMap_Values, Object) -> boolean
     * Source: java/util/HashMap.Values.lsl:117
     */
    public boolean add(Object e) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (true) {
                throw new UnsupportedOperationException();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::addAll(HashMap_Values, Collection) -> boolean
     * Source: java/util/HashMap.Values.lsl:125
     */
    public boolean addAll(Collection c) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (true) {
                throw new UnsupportedOperationException();
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::clear(HashMap_Values) -> void
     * Source: java/util/HashMap.Values.lsl:132
     */
    public final void clear() {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            ((HashMap) ((Object) this.parent)).modCount += 1;
            final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> newStorage = new LibSLRuntime.Map<>(new LibSLRuntime.HashMapContainer<>());
            ((HashMap) ((Object) this.parent)).storage = newStorage;
            this.storageRef = newStorage;
        }
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::contains(HashMap_Values, Object) -> boolean
     * Source: java/util/HashMap.Values.lsl:142
     */
    public final boolean contains(Object value) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = false;
            int storageSize = this.storageRef.size();
            if (storageSize != 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                while ((result != true) && (storageSize != 0)) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (LibSLRuntime.equals(curValue, value)) {
                        result = true;
                    }
                    unseen.remove(curKey);
                    storageSize -= 1;
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::containsAll(HashMap_Values, Collection) -> boolean
     * Source: java/util/HashMap.Values.lsl:171
     */
    public boolean containsAll(Collection c) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = true;
            final int thisSize = this.storageRef.size();
            if ((thisSize != 0) && (c != this)) {
                Engine.assume(thisSize > 0);
                final int otherSize = c.size();
                if (otherSize > 0) {
                    int i = 0;
                    final Object[] thisValues = new Object[thisSize];
                    final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                    for (i = 0; i < thisSize; i += 1) {
                        final Object key = unseen.anyKey();
                        final Map.Entry<Object, Object> entry = unseen.get(key);
                        thisValues[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                        unseen.remove(key);
                    }
                    ;
                    final Iterator<Object> iter = c.iterator();
                    while (result && iter.hasNext()) {
                        final Object value = iter.next();
                        result = false;
                        i = 0;
                        while ((!result) && (i != thisSize)) {
                            result = LibSLRuntime.equals(thisValues[i], value);
                            i += 1;
                        }
                        ;
                    }
                    ;
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::forEach(HashMap_Values, Consumer) -> void
     * Source: java/util/HashMap.Values.lsl:267
     */
    public final void forEach(Consumer userAction) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (userAction == null) {
                throw new NullPointerException();
            }
            final int storageSize = this.storageRef.size();
            if (storageSize > 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                final int expectedModCount = ((HashMap) ((Object) this.parent)).modCount;
                int i = 0;
                for (i = 0; i < storageSize; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    userAction.accept(curValue);
                    unseen.remove(curKey);
                }
                ;
                ((HashMap) ((Object) this.parent))._checkForComodification(expectedModCount);
            }
        }
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::isEmpty(HashMap_Values) -> boolean
     * Source: java/util/HashMap.Values.lsl:298
     */
    public boolean isEmpty() {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storageRef.size() == 0;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::iterator(HashMap_Values) -> Iterator
     * Source: java/util/HashMap.Values.lsl:304
     */
    public final Iterator iterator() {
        Iterator result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = (stub.java.util.HashMap_ValueIterator) ((Object) new HashMap_ValueIterator((Void) null, 
                /* state = */ HashMap_ValueIterator.__$lsl_States.Initialized, 
                /* parent = */ this.parent, 
                /* unseen = */ this.storageRef.duplicate(), 
                /* expectedModCount = */ ((HashMap) ((Object) this.parent)).modCount, 
                /* currentKey = */ null
            ));
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::parallelStream(HashMap_Values) -> Stream
     * Source: java/util/HashMap.Values.lsl:315
     */
    public Stream parallelStream() {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final Object[] items = _mapToValuesArray();
            result = (StreamLSL) ((Object) new generated.java.util.stream.StreamLSL((Void) null, 
                /* state = */ generated.java.util.stream.StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ items, 
                /* length = */ items.length, 
                /* closeHandlers = */ Engine.makeSymbolicList(), 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            ));
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::remove(HashMap_Values, Object) -> boolean
     * Source: java/util/HashMap.Values.lsl:328
     */
    public boolean remove(Object value) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = false;
            final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
            int thisSize = this.storageRef.size();
            int i = 0;
            if (value == null) {
                while ((result != true) && (thisSize != 0)) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (curValue == null) {
                        this.storageRef.remove(curKey);
                        result = true;
                        ((HashMap) ((Object) this.parent)).modCount += 1;
                    }
                    unseen.remove(curKey);
                    thisSize -= 1;
                }
                ;
            } else {
                while ((result != true) && (thisSize != 0)) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (LibSLRuntime.equals(value, curValue)) {
                        this.storageRef.remove(curKey);
                        result = true;
                        ((HashMap) ((Object) this.parent)).modCount += 1;
                    }
                    unseen.remove(curKey);
                    thisSize -= 1;
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::removeAll(HashMap_Values, Collection) -> boolean
     * Source: java/util/HashMap.Values.lsl:385
     */
    public boolean removeAll(Collection c) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (c == null) {
                throw new NullPointerException();
            }
            result = false;
            final int startStorageSize = this.storageRef.size();
            final int cSize = c.size();
            if ((startStorageSize != 0) && (cSize != 0)) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < startStorageSize; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (c.contains(curValue)) {
                        this.storageRef.remove(curKey);
                        ((HashMap) ((Object) this.parent)).modCount += 1;
                    }
                    unseen.remove(curKey);
                }
                ;
                final int resultStorageSize = this.storageRef.size();
                result = startStorageSize != resultStorageSize;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::removeIf(HashMap_Values, Predicate) -> boolean
     * Source: java/util/HashMap.Values.lsl:424
     */
    public boolean removeIf(Predicate filter) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (filter == null) {
                throw new NullPointerException();
            }
            result = false;
            final int startStorageSize = this.storageRef.size();
            if (startStorageSize != 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < startStorageSize; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (filter.test(curValue)) {
                        this.storageRef.remove(curKey);
                        ((HashMap) ((Object) this.parent)).modCount += 1;
                    }
                    unseen.remove(curKey);
                }
                ;
                final int resultStorageSize = this.storageRef.size();
                result = startStorageSize != resultStorageSize;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::retainAll(HashMap_Values, Collection) -> boolean
     * Source: java/util/HashMap.Values.lsl:462
     */
    public boolean retainAll(Collection c) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (c == null) {
                throw new NullPointerException();
            }
            result = false;
            final int startStorageSize = this.storageRef.size();
            final int cSize = c.size();
            if ((startStorageSize != 0) && (cSize != 0)) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < startStorageSize; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    final Object curValue = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    if (!c.contains(curValue)) {
                        this.storageRef.remove(curKey);
                        ((HashMap) ((Object) this.parent)).modCount += 1;
                    }
                    unseen.remove(curKey);
                }
                ;
                final int resultStorageSize = this.storageRef.size();
                result = startStorageSize != resultStorageSize;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::size(HashMap_Values) -> int
     * Source: java/util/HashMap.Values.lsl:500
     */
    public final int size() {
        int result = 0;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.storageRef.size();
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::spliterator(HashMap_Values) -> Spliterator
     * Source: java/util/HashMap.Values.lsl:506
     */
    public final Spliterator spliterator() {
        Spliterator result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = (stub.java.util.HashMap_ValueSpliterator) ((Object) new HashMap_ValueSpliterator((Void) null, 
                /* state = */ HashMap_ValueSpliterator.__$lsl_States.Initialized, 
                /* valuesStorage = */ _mapToValuesArray(), 
                /* parent = */ this.parent, 
                /* index = */ 0, 
                /* fence = */ -1, 
                /* est = */ 0, 
                /* expectedModCount = */ 0
            ));
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::stream(HashMap_Values) -> Stream
     * Source: java/util/HashMap.Values.lsl:516
     */
    public Stream stream() {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final Object[] items = _mapToValuesArray();
            result = (StreamLSL) ((Object) new generated.java.util.stream.StreamLSL((Void) null, 
                /* state = */ generated.java.util.stream.StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ items, 
                /* length = */ items.length, 
                /* closeHandlers = */ Engine.makeSymbolicList(), 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            ));
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::toArray(HashMap_Values) -> array<Object>
     * Source: java/util/HashMap.Values.lsl:528
     */
    public Object[] toArray() {
        Object[] result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int len = this.storageRef.size();
            result = new Object[len];
            if (len != 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < len; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    result[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    unseen.remove(curKey);
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::toArray(HashMap_Values, IntFunction) -> array<Object>
     * Source: java/util/HashMap.Values.lsl:555
     */
    public Object[] toArray(IntFunction generator) {
        Object[] result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final Object[] a = ((Object[]) generator.apply(0));
            final int aLen = a.length;
            final int len = this.storageRef.size();
            result = new Object[len];
            if (len != 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < len; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    result[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    unseen.remove(curKey);
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::toArray(HashMap_Values, array<Object>) -> array<Object>
     * Source: java/util/HashMap.Values.lsl:577
     */
    public Object[] toArray(Object[] a) {
        Object[] result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int aLen = a.length;
            final int len = this.storageRef.size();
            if (aLen < len) {
                a = new Object[len];
            }
            result = a;
            if (len != 0) {
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < len; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    result[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    unseen.remove(curKey);
                }
                ;
                if (aLen > len) {
                    result[len] = null;
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_ValuesAutomaton::toString(HashMap_Values) -> String
     * Source: java/util/HashMap.Values.lsl:603
     */
    public String toString() {
        String result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int storageSize = this.storageRef.size();
            if (storageSize != 0) {
                final Object[] arrayValues = new Object[storageSize];
                final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen = this.storageRef.duplicate();
                int i = 0;
                for (i = 0; i < storageSize; i += 1) {
                    final Object curKey = unseen.anyKey();
                    final Map.Entry<Object, Object> entry = unseen.get(curKey);
                    arrayValues[i] = ((AbstractMap_SimpleEntry) ((Object) entry)).value;
                    unseen.remove(curKey);
                }
                ;
                result = LibSLRuntime.toString(arrayValues);
            } else {
                result = "[]";
            }
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Allocated = (byte) 0;

        public static final byte Initialized = (byte) 1;
    }

    @Approximate(HashMap_Values.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
