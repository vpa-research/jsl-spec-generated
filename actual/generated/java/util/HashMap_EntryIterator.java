// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - java/util/HashMap.lsl:99
//  - java/util/HashMap.EntryIterator.lsl:20
//
package generated.java.util;

import java.lang.IllegalStateException;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.SuppressWarnings;
import java.lang.Void;
import java.util.ConcurrentModificationException;
import java.util.Iterator;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.function.Consumer;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;

/**
 * HashMap_EntryIteratorAutomaton for HashMap_EntryIterator ~> java.util.HashMap_EntryIterator
 */
@SuppressWarnings({"all", "unchecked"})
@Approximate(stub.java.util.HashMap_EntryIterator.class)
public final class HashMap_EntryIterator implements LibSLRuntime.Automaton, Iterator {
    static {
        Engine.assume(true);
    }

    public HashMap parent;

    public LibSLRuntime.Map<Object, Map.Entry<Object, Object>> unseen;

    public int expectedModCount;

    public Object currentKey;

    @LibSLRuntime.AutomatonConstructor
    public HashMap_EntryIterator(Void __$lsl_token, final byte p0, final HashMap p1,
            final LibSLRuntime.Map<Object, Map.Entry<Object, Object>> p2, final int p3,
            final Object p4) {
        this.parent = p1;
        this.unseen = p2;
        this.expectedModCount = p3;
        this.currentKey = p4;
    }

    @LibSLRuntime.AutomatonConstructor
    public HashMap_EntryIterator(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, null, null, 0, null);
    }

    /**
     * [SUBROUTINE] HashMap_EntryIteratorAutomaton::_checkForComodification() -> void
     * Source: java/util/HashMap.EntryIterator.lsl:53
     */
    private void _checkForComodification() {
        /* body */ {
            final int modCount = ((HashMap) ((Object) this.parent)).modCount;
            if (modCount != this.expectedModCount) {
                throw new ConcurrentModificationException();
            }
        }
    }

    /**
     * [FUNCTION] HashMap_EntryIteratorAutomaton::forEachRemaining(HashMap_EntryIterator, Consumer) -> void
     * Source: java/util/HashMap.EntryIterator.lsl:68
     */
    public void forEachRemaining(Consumer userAction) {
        /* body */ {
            if (userAction == null) {
                throw new NullPointerException();
            }
            int size = this.unseen.size();
            if (size != 0) {
                while ((size != 0) && (((HashMap) ((Object) this.parent)).modCount == this.expectedModCount)) {
                    _checkForComodification();
                    final Object curKey = this.unseen.anyKey();
                    userAction.accept(this.unseen.get(curKey));
                    this.unseen.remove(curKey);
                    size -= 1;
                }
                ;
            }
        }
    }

    /**
     * [FUNCTION] HashMap_EntryIteratorAutomaton::hasNext(HashMap_EntryIterator) -> boolean
     * Source: java/util/HashMap.EntryIterator.lsl:96
     */
    public final boolean hasNext() {
        boolean result = false;
        /* body */ {
            result = this.unseen.size() != 0;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_EntryIteratorAutomaton::next(HashMap_EntryIterator) -> Map_Entry
     * Source: java/util/HashMap.EntryIterator.lsl:102
     */
    public final Map.Entry next() {
        Map.Entry result = null;
        /* body */ {
            _checkForComodification();
            if (this.unseen.size() == 0) {
                throw new NoSuchElementException();
            }
            final Object curKey = this.unseen.anyKey();
            result = this.unseen.get(curKey);
            this.unseen.remove(curKey);
            this.currentKey = curKey;
        }
        return result;
    }

    /**
     * [FUNCTION] HashMap_EntryIteratorAutomaton::remove(HashMap_EntryIterator) -> void
     * Source: java/util/HashMap.EntryIterator.lsl:119
     */
    public final void remove() {
        /* body */ {
            Engine.assume(this.parent != null);
            final Object key = this.currentKey;
            if (key == null) {
                throw new IllegalStateException();
            }
            _checkForComodification();
            ((HashMap) ((Object) this.parent)).storage.remove(key);
            ((HashMap) ((Object) this.parent)).modCount += 1;
            this.unseen.remove(key);
            this.expectedModCount = ((HashMap) ((Object) this.parent)).modCount;
            this.currentKey = null;
        }
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(HashMap_EntryIterator.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
