// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.util.stream;

import generated.runtime.LibSLGlobals;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.Long;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.Runnable;
import java.lang.Void;
import java.util.LongSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalLong;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.LongBinaryOperator;
import java.util.function.LongConsumer;
import java.util.function.LongFunction;
import java.util.function.LongPredicate;
import java.util.function.LongToDoubleFunction;
import java.util.function.LongToIntFunction;
import java.util.function.LongUnaryOperator;
import java.util.function.ObjLongConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import org.usvm.api.SymbolicList;
import runtime.LibSLRuntime;

/**
 * LongStreamAutomaton for LongStreamLSL ~> java.util.stream.LongStreamLSL
 */
@Approximate(stub.java.util.stream.LongStreamLSL.class)
public class LongStreamLSL implements LibSLRuntime.Automaton, LongStream {
    static {
        Engine.assume(true);
    }

    public long[] storage;

    public transient int length;

    public SymbolicList<Runnable> closeHandlers;

    public boolean isParallel;

    public boolean linkedOrConsumed;

    @LibSLRuntime.AutomatonConstructor
    public LongStreamLSL(Void __$lsl_token, final byte p0, final long[] p1, final int p2,
            final SymbolicList<Runnable> p3, final boolean p4, final boolean p5) {
        this.storage = p1;
        this.length = p2;
        this.closeHandlers = p3;
        this.isParallel = p4;
        this.linkedOrConsumed = p5;
    }

    @LibSLRuntime.AutomatonConstructor
    public LongStreamLSL(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, null, 0, null, false, false);
    }

    /**
     * [SUBROUTINE] LongStreamAutomaton::_actionApply(LongConsumer) -> void
     */
    private void _actionApply(LongConsumer _action) {
        /* body */ {
            if (_action == null) {
                throw new NullPointerException();
            }
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                _action.accept(storage[i]);
            }
            ;
        }
    }

    /**
     * [SUBROUTINE] LongStreamAutomaton::_findFirst() -> OptionalLong
     */
    private OptionalLong _findFirst() {
        OptionalLong result = null;
        /* body */ {
            if (this.length == 0) {
                result = OptionalLong.empty();
            } else {
                final long first = storage[0];
                result = OptionalLong.of(first);
            }
        }
        return result;
    }

    /**
     * [SUBROUTINE] LongStreamAutomaton::_sum() -> long
     */
    private long _sum() {
        long result = 0L;
        /* body */ {
            result = 0;
            if (this.length != 0) {
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result += storage[i];
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::filter(LongStream, LongPredicate) -> LongStream
     */
    public LongStream filter(LongPredicate predicate) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            long[] filteredStorage = new long[this.length];
            int filteredLength = 0;
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                if (predicate.test(storage[i])) {
                    filteredStorage[filteredLength] = storage[i];
                    filteredLength += 1;
                }
            }
            ;
            Engine.assume(filteredLength <= this.length);
            long[] resultStorage = new long[filteredLength];
            LibSLRuntime.ArrayActions.copy(filteredStorage, 0, resultStorage, 0, filteredLength);
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ resultStorage, 
            /* length = */ filteredLength, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::map(LongStream, LongUnaryOperator) -> LongStream
     */
    public LongStream map(LongUnaryOperator mapper) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            long[] mappedStorage = new long[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsLong(storage[i]);
            }
            ;
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::mapToObj(LongStream, LongFunction) -> Stream
     */
    public Stream mapToObj(LongFunction mapper) {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Object[] objStorage = new Object[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                objStorage[i] = mapper.apply(storage[i]);
            }
            ;
            result = new StreamLSL((Void) null, 
            /* state = */ StreamLSL.__$lsl_States.Initialized, 
            /* storage = */ objStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::mapToInt(LongStream, LongToIntFunction) -> IntStream
     */
    public IntStream mapToInt(LongToIntFunction mapper) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            int[] mappedStorage = new int[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsInt(storage[i]);
            }
            ;
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::mapToDouble(LongStream, LongToDoubleFunction) -> DoubleStream
     */
    public DoubleStream mapToDouble(LongToDoubleFunction mapper) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            double[] mappedStorage = new double[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsDouble(storage[i]);
            }
            ;
            result = new DoubleStreamLSL((Void) null, 
            /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::flatMap(LongStream, LongFunction) -> LongStream
     */
    public LongStream flatMap(LongFunction mapper) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(LongStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::sorted(LongStream) -> LongStream
     */
    public LongStream sorted() {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                final int outerLimit = this.length - 1;
                int innerLimit = 0;
                int i = 0;
                int j = 0;
                for (i = 0; i < outerLimit; i += 1) {
                    innerLimit = (this.length - i) - 1;
                    for (j = 0; j < innerLimit; j += 1) {
                        final int idxA = j;
                        final int idxB = j + 1;
                        final long a = storage[idxA];
                        final long b = storage[idxB];
                        if (a > b) {
                            storage[idxA] = b;
                            storage[idxB] = a;
                        }
                    }
                    ;
                }
                ;
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::distinct(LongStream) -> LongStream
     */
    public LongStream distinct() {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            long[] distinctStorage = null;
            int distinctLength = 0;
            final int size = this.length;
            if (size == 0) {
                distinctStorage = new long[0];
                distinctLength = 0;
            } else {
                final long[] items = this.storage;
                Engine.assume(items != null);
                Engine.assume(items.length != 0);
                Engine.assume(size == items.length);
                int i = 0;
                int j = 0;
                final SymbolicList<Long> uniqueItems = Engine.makeSymbolicList();
                final LibSLRuntime.Map<Long, Object> visited = new LibSLRuntime.Map<>(new LibSLRuntime.HashMapContainer<>());
                for (i = 0; i < size; i += 1) {
                    final long item = items[i];
                    if (!visited.hasKey(item)) {
                        visited.set(item, LibSLGlobals.SOMETHING);
                        uniqueItems.insert(j, item);
                        j += 1;
                    }
                }
                ;
                distinctLength = j;
                Engine.assume(distinctLength > 0);
                Engine.assume(distinctLength <= size);
                distinctStorage = new long[distinctLength];
                for (i = 0; i < distinctLength; i += 1) {
                    final Long item = uniqueItems.get(i);
                    Engine.assume(item != null);
                    distinctStorage[i] = ((long) item);
                }
                ;
            }
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ distinctStorage, 
            /* length = */ distinctLength, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::peek(Stream, LongConsumer) -> LongStream
     */
    public LongStream peek(LongConsumer _action) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ this.storage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::limit(LongStream, long) -> LongStream
     */
    public LongStream limit(long maxSize) {
        LongStream result = null;
        /* body */ {
            final int maxSizeInt = ((int) maxSize);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (maxSizeInt < 0) {
                throw new IllegalArgumentException();
            }
            if (maxSizeInt == 0) {
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                if (maxSizeInt > this.length) {
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final long[] limitStorage = new long[maxSizeInt];
                    LibSLRuntime.ArrayActions.copy(this.storage, 0, limitStorage, 0, maxSizeInt);
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ limitStorage, 
                    /* length = */ maxSizeInt, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::skip(LongStream, long) -> LongStream
     */
    public LongStream skip(long n) {
        LongStream result = null;
        /* body */ {
            final int offset = ((int) n);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (offset < 0) {
                throw new IllegalArgumentException();
            }
            if (offset == 0) {
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                if (offset >= this.length) {
                    long[] newArray = {};
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newArray, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = this.length - offset;
                    final long[] skipStorage = new long[newLength];
                    int i = 0;
                    int skipIndex = 0;
                    for (i = offset; i < this.length; i += 1) {
                        skipStorage[skipIndex] = storage[i];
                        skipIndex += 1;
                    }
                    ;
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ skipStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::forEach(LongStream, LongConsumer) -> void
     */
    public void forEach(LongConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] LongStreamAutomaton::forEachOrdered(LongStream, LongConsumer) -> void
     */
    public void forEachOrdered(LongConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] LongStreamAutomaton::toArray(LongStream) -> array<long>
     */
    public long[] toArray() {
        long[] result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.storage;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::reduce(LongStream, long, LongBinaryOperator) -> long
     */
    public long reduce(long identity, LongBinaryOperator accumulator) {
        long result = 0L;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            result = identity;
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result = accumulator.applyAsLong(result, storage[i]);
                }
                ;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::reduce(LongStream, LongBinaryOperator) -> OptionalLong
     */
    public OptionalLong reduce(LongBinaryOperator accumulator) {
        OptionalLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                result = OptionalLong.empty();
            } else {
                if (this.length > 0) {
                    long value = storage[0];
                    int i = 0;
                    for (i = 1; i < this.length; i += 1) {
                        value = accumulator.applyAsLong(value, storage[i]);
                    }
                    ;
                    result = OptionalLong.of(value);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::collect(LongStream, Supplier, ObjLongConsumer, BiConsumer) -> Object
     */
    public Object collect(Supplier supplier, ObjLongConsumer accumulator, BiConsumer combiner) {
        Object result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (supplier == null) {
                throw new NullPointerException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (combiner == null) {
                throw new NullPointerException();
            }
            result = supplier.get();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                accumulator.accept(result, storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::min(LongStream) -> OptionalLong
     */
    public OptionalLong min() {
        OptionalLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalLong.empty();
            } else {
                long min = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (min > storage[i]) {
                        min = storage[i];
                    }
                }
                ;
                result = OptionalLong.of(min);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::max(IntStream) -> OptionalLong
     */
    public OptionalLong max() {
        OptionalLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalLong.empty();
            } else {
                long max = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (max < storage[i]) {
                        max = storage[i];
                    }
                }
                ;
                result = OptionalLong.of(max);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::count(LongStream) -> long
     */
    public long count() {
        long result = 0L;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.length;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::anyMatch(LongStream, LongPredicate) -> boolean
     */
    public boolean anyMatch(LongPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = false;
            int i = 0;
            while ((i < this.length) && !predicate.test(storage[i])) {
                i += 1;
            }
            ;
            if (i < this.length) {
                result = true;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::allMatch(LongStream, LongPredicate) -> boolean
     */
    public boolean allMatch(LongPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::noneMatch(LongStream, LongPredicate) -> boolean
     */
    public boolean noneMatch(LongPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && !predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::findFirst(LongStream) -> OptionalLong
     */
    public OptionalLong findFirst() {
        OptionalLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::findAny(LongStream) -> OptionalLong
     */
    public OptionalLong findAny() {
        OptionalLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::iterator(LongStream) -> PrimitiveIterator_OfLong
     */
    public PrimitiveIterator.OfLong iterator() {
        PrimitiveIterator.OfLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new LongStreamLSLIterator((Void) null, 
            /* state = */ LongStreamLSLIterator.__$lsl_States.Initialized, 
            /* parent = */ this, 
            /* cursor = */ 0);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::spliterator(LongStream) -> Spliterator_OfLong
     */
    public Spliterator.OfLong spliterator() {
        Spliterator.OfLong result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = Engine.makeSymbolic(Spliterator.OfLong.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::isParallel(LongStream) -> boolean
     */
    public boolean isParallel() {
        boolean result = false;
        /* body */ {
            result = this.isParallel;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::sequential(LongStream) -> LongStream
     */
    public LongStream sequential() {
        LongStream result = null;
        /* body */ {
            this.isParallel = false;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::parallel(LongStream) -> LongStream
     */
    public LongStream parallel() {
        LongStream result = null;
        /* body */ {
            this.isParallel = true;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::unordered(LongStream) -> LongStream
     */
    public LongStream unordered() {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ this.storage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::onClose(LongStream, Runnable) -> LongStream
     */
    public LongStream onClose(Runnable closeHandler) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final int listLength = this.closeHandlers.size();
            this.closeHandlers.insert(listLength, closeHandler);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::close(LongStream) -> void
     */
    public void close() {
        /* body */ {
            final int listLength = this.closeHandlers.size();
            int i = 0;
            for (i = 0; i < listLength; i += 1) {
                final Runnable currentHandler = ((Runnable) this.closeHandlers.get(i));
                currentHandler.run();
            }
            ;
            this.closeHandlers = Engine.makeSymbolicList();
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] LongStreamAutomaton::dropWhile(LongStream, LongPredicate) -> LongStream
     */
    public LongStream dropWhile(LongPredicate predicate) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final long[] emptyStorage = new long[0];
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyStorage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                int dropLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    dropLength += 1;
                    i += 1;
                }
                ;
                if (dropLength == 0) {
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = this.length - dropLength;
                    final long[] newStorage = new long[newLength];
                    int j = dropLength;
                    i = dropLength;
                    while (i < this.length) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::takeWhile(LongStream, LongPredicate) -> LongStream
     */
    public LongStream takeWhile(LongPredicate predicate) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final long[] emptyStorage = new long[0];
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyStorage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                int takeLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    takeLength += 1;
                    i += 1;
                }
                ;
                if (takeLength == this.length) {
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = takeLength;
                    final long[] newStorage = new long[newLength];
                    int j = 0;
                    i = 0;
                    while (i < takeLength) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new LongStreamLSL((Void) null, 
                    /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::asDoubleStream(LongStream) -> DoubleStream
     */
    public DoubleStream asDoubleStream() {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                final double[] emptyArray = {};
                result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyArray, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                final double[] newStorage = new double[this.length];
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    newStorage[i] = ((double) storage[i]);
                }
                ;
                result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ newStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::sum(LongStream) -> long
     */
    public long sum() {
        long result = 0L;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _sum();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::average(LongStream) -> OptionalDouble
     */
    public OptionalDouble average() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                double curSum = _sum();
                double divisionResult = curSum / this.length;
                result = OptionalDouble.of(divisionResult);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::summaryStatistics(LongStream) -> LongSummaryStatistics
     */
    public LongSummaryStatistics summaryStatistics() {
        LongSummaryStatistics result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new LongSummaryStatistics();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                result.accept(storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] LongStreamAutomaton::boxed(LongStream) -> Stream
     */
    public Stream boxed() {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Long[] longArray = new Long[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                longArray[i] = storage[i];
            }
            ;
            result = new StreamLSL((Void) null, 
            /* state = */ StreamLSL.__$lsl_States.Initialized, 
            /* storage = */ longArray, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(LongStreamLSL.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
