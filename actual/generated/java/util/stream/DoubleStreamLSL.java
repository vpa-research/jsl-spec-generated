// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.util.stream;

import generated.runtime.LibSLGlobals;
import java.lang.Double;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.Runnable;
import java.lang.Void;
import java.util.DoubleSummaryStatistics;
import java.util.OptionalDouble;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleConsumer;
import java.util.function.DoubleFunction;
import java.util.function.DoublePredicate;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.ObjDoubleConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import org.usvm.api.SymbolicList;
import runtime.LibSLRuntime;

/**
 * DoubleStreamAutomaton for DoubleStreamLSL ~> java.util.stream.DoubleStreamLSL
 */
@Approximate(stub.java.util.stream.DoubleStreamLSL.class)
public class DoubleStreamLSL implements LibSLRuntime.Automaton, DoubleStream {
    static {
        Engine.assume(true);
    }

    public double[] storage;

    public transient int length;

    public SymbolicList<Runnable> closeHandlers;

    public boolean isParallel;

    public boolean linkedOrConsumed;

    @LibSLRuntime.AutomatonConstructor
    public DoubleStreamLSL(Void __$lsl_token, final byte p0, final double[] p1, final int p2,
            final SymbolicList<Runnable> p3, final boolean p4, final boolean p5) {
        this.storage = p1;
        this.length = p2;
        this.closeHandlers = p3;
        this.isParallel = p4;
        this.linkedOrConsumed = p5;
    }

    @LibSLRuntime.AutomatonConstructor
    public DoubleStreamLSL(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, null, 0, null, false, false);
    }

    /**
     * [SUBROUTINE] DoubleStreamAutomaton::_actionApply(DoubleConsumer) -> void
     */
    private void _actionApply(DoubleConsumer _action) {
        /* body */ {
            if (_action == null) {
                throw new NullPointerException();
            }
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                _action.accept(storage[i]);
            }
            ;
        }
    }

    /**
     * [SUBROUTINE] DoubleStreamAutomaton::_findFirst() -> OptionalDouble
     */
    private OptionalDouble _findFirst() {
        OptionalDouble result = null;
        /* body */ {
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                final double first = storage[0];
                result = OptionalDouble.of(first);
            }
        }
        return result;
    }

    /**
     * [SUBROUTINE] DoubleStreamAutomaton::_sum() -> double
     */
    private double _sum() {
        double result = 0.0d;
        /* body */ {
            result = 0;
            if (this.length != 0) {
                boolean anyNaN = false;
                boolean anyPositiveInfinity = false;
                boolean anyNegativeInfinity = false;
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    final double element = storage[i];
                    result += element;
                    if (Double.isNaN(element)) {
                        anyNaN = true;
                    }
                    if (element == LibSLGlobals.DOUBLE_POSITIVE_INFINITY) {
                        anyPositiveInfinity = true;
                    }
                    if (element == LibSLGlobals.DOUBLE_NEGATIVE_INFINITY) {
                        anyNegativeInfinity = true;
                    }
                }
                ;
                if (anyNaN) {
                    result = LibSLGlobals.DOUBLE_NAN;
                } else {
                    if (anyPositiveInfinity && anyNegativeInfinity) {
                        result = LibSLGlobals.DOUBLE_NAN;
                    } else {
                        if (anyPositiveInfinity && (result == LibSLGlobals.DOUBLE_NEGATIVE_INFINITY)) {
                            result = LibSLGlobals.DOUBLE_NAN;
                        } else {
                            if (anyNegativeInfinity && (result == LibSLGlobals.DOUBLE_POSITIVE_INFINITY)) {
                                result = LibSLGlobals.DOUBLE_NAN;
                            }
                        }
                    }
                }
            }
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::filter(DoubleStream, DoublePredicate) -> DoubleStream
     */
    public DoubleStream filter(DoublePredicate predicate) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            double[] filteredStorage = new double[this.length];
            int filteredLength = 0;
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                if (predicate.test(storage[i])) {
                    filteredStorage[filteredLength] = storage[i];
                    filteredLength += 1;
                }
            }
            ;
            Engine.assume(filteredLength <= this.length);
            double[] resultStorage = new double[filteredLength];
            LibSLRuntime.ArrayActions.copy(filteredStorage, 0, resultStorage, 0, filteredLength);
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ resultStorage, 
                /* length = */ filteredLength, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::map(DoubleStream, DoubleUnaryOperator) -> DoubleStream
     */
    public DoubleStream map(DoubleUnaryOperator mapper) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            double[] mappedStorage = new double[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsDouble(storage[i]);
            }
            ;
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::mapToObj(DoubleStream, DoubleFunction) -> Stream
     */
    public Stream mapToObj(DoubleFunction mapper) {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Object[] objStorage = new Object[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                objStorage[i] = mapper.apply(storage[i]);
            }
            ;
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ objStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::mapToLong(DoubleStream, DoubleToLongFunction) -> LongStream
     */
    public LongStream mapToLong(DoubleToLongFunction mapper) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            long[] mappedStorage = new long[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsLong(storage[i]);
            }
            ;
            result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::mapToInt(DoubleStream, DoubleToIntFunction) -> IntStream
     */
    public IntStream mapToInt(DoubleToIntFunction mapper) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            int[] mappedStorage = new int[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsInt(storage[i]);
            }
            ;
            result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::flatMap(DoubleStream, DoubleFunction) -> DoubleStream
     */
    public DoubleStream flatMap(DoubleFunction mapper) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(DoubleStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::sorted(DoubleStream) -> DoubleStream
     */
    public DoubleStream sorted() {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                Engine.assume(this.length > 0);
                final int outerLimit = this.length - 1;
                int innerLimit = 0;
                int i = 0;
                int j = 0;
                for (i = 0; i < outerLimit; i += 1) {
                    innerLimit = (this.length - i) - 1;
                    for (j = 0; j < innerLimit; j += 1) {
                        final int idxA = j;
                        final int idxB = j + 1;
                        final double a = storage[idxA];
                        final double b = storage[idxB];
                        if (a > b) {
                            storage[idxA] = b;
                            storage[idxB] = a;
                        }
                    }
                    ;
                }
                ;
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::distinct(DoubleStream) -> DoubleStream
     */
    public DoubleStream distinct() {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            double[] distinctStorage = null;
            int distinctLength = 0;
            final int size = this.length;
            if (size == 0) {
                distinctStorage = new double[0];
                distinctLength = 0;
            } else {
                final double[] items = this.storage;
                Engine.assume(items != null);
                Engine.assume(items.length != 0);
                Engine.assume(size == items.length);
                int i = 0;
                int j = 0;
                final SymbolicList<Double> uniqueItems = Engine.makeSymbolicList();
                final LibSLRuntime.Map<Double, Object> visited = new LibSLRuntime.Map<>(new LibSLRuntime.HashMapContainer<>());
                for (i = 0; i < size; i += 1) {
                    final double item = items[i];
                    if (!visited.hasKey(item)) {
                        visited.set(item, LibSLGlobals.SOMETHING);
                        uniqueItems.insert(j, item);
                        j += 1;
                    }
                }
                ;
                distinctLength = j;
                Engine.assume(distinctLength > 0);
                Engine.assume(distinctLength <= size);
                distinctStorage = new double[distinctLength];
                for (i = 0; i < distinctLength; i += 1) {
                    final Double item = uniqueItems.get(i);
                    Engine.assume(item != null);
                    distinctStorage[i] = ((double) item);
                }
                ;
            }
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ distinctStorage, 
                /* length = */ distinctLength, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::peek(Stream, DoubleConsumer) -> DoubleStream
     */
    public DoubleStream peek(DoubleConsumer _action) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::limit(DoubleStream, long) -> DoubleStream
     */
    public DoubleStream limit(long maxSize) {
        DoubleStream result = null;
        /* body */ {
            final int maxSizeInt = ((int) maxSize);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (maxSizeInt < 0) {
                throw new IllegalArgumentException();
            }
            if (maxSizeInt == 0) {
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                if (maxSizeInt > this.length) {
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ this.storage, 
                        /* length = */ this.length, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final double[] limitStorage = new double[maxSizeInt];
                    LibSLRuntime.ArrayActions.copy(this.storage, 0, limitStorage, 0, maxSizeInt);
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ limitStorage, 
                        /* length = */ maxSizeInt, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::skip(DoubleStream, long) -> DoubleStream
     */
    public DoubleStream skip(long n) {
        DoubleStream result = null;
        /* body */ {
            final int offset = ((int) n);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (offset < 0) {
                throw new IllegalArgumentException();
            }
            if (offset == 0) {
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                if (offset >= this.length) {
                    double[] newArray = {};
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ newArray, 
                        /* length = */ 0, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final int newLength = this.length - offset;
                    final double[] skipStorage = new double[newLength];
                    int i = 0;
                    int skipIndex = 0;
                    for (i = offset; i < this.length; i += 1) {
                        skipStorage[skipIndex] = storage[i];
                        skipIndex += 1;
                    }
                    ;
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ skipStorage, 
                        /* length = */ newLength, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::forEach(DoubleStream, DoubleConsumer) -> void
     */
    public void forEach(DoubleConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::forEachOrdered(DoubleStream, DoubleConsumer) -> void
     */
    public void forEachOrdered(DoubleConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::toArray(DoubleStream) -> array<double>
     */
    public double[] toArray() {
        double[] result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.storage;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::reduce(DoubleStream, double, DoubleBinaryOperator) -> double
     */
    public double reduce(double identity, DoubleBinaryOperator accumulator) {
        double result = 0.0d;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            result = identity;
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result = accumulator.applyAsDouble(result, storage[i]);
                }
                ;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::reduce(DoubleStream, DoubleBinaryOperator) -> OptionalDouble
     */
    public OptionalDouble reduce(DoubleBinaryOperator accumulator) {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                if (this.length > 0) {
                    double value = storage[0];
                    int i = 0;
                    for (i = 1; i < this.length; i += 1) {
                        value = accumulator.applyAsDouble(value, storage[i]);
                    }
                    ;
                    result = OptionalDouble.of(value);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::collect(DoubleStream, Supplier, ObjDoubleConsumer, BiConsumer) -> Object
     */
    public Object collect(Supplier supplier, ObjDoubleConsumer accumulator, BiConsumer combiner) {
        Object result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (supplier == null) {
                throw new NullPointerException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (combiner == null) {
                throw new NullPointerException();
            }
            result = supplier.get();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                accumulator.accept(result, storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::min(DoubleStream) -> OptionalDouble
     */
    public OptionalDouble min() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                double min = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (min > storage[i]) {
                        min = storage[i];
                    }
                }
                ;
                result = OptionalDouble.of(min);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::max(DoubleStream) -> OptionalDouble
     */
    public OptionalDouble max() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                double max = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (max < storage[i]) {
                        max = storage[i];
                    }
                }
                ;
                result = OptionalDouble.of(max);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::count(DoubleStream) -> long
     */
    public long count() {
        long result = 0L;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.length;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::anyMatch(DoubleStream, DoublePredicate) -> boolean
     */
    public boolean anyMatch(DoublePredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = false;
            int i = 0;
            while ((i < this.length) && !predicate.test(storage[i])) {
                i += 1;
            }
            ;
            if (i < this.length) {
                result = true;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::allMatch(DoubleStream, DoublePredicate) -> boolean
     */
    public boolean allMatch(DoublePredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::noneMatch(DoubleStream, DoublePredicate) -> boolean
     */
    public boolean noneMatch(DoublePredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && !predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::findFirst(DoubleStream) -> OptionalDouble
     */
    public OptionalDouble findFirst() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::findAny(DoubleStream) -> OptionalDouble
     */
    public OptionalDouble findAny() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::iterator(DoubleStream) -> PrimitiveIterator_OfDouble
     */
    public PrimitiveIterator.OfDouble iterator() {
        PrimitiveIterator.OfDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new DoubleStreamLSLIterator((Void) null, 
                /* state = */ DoubleStreamLSLIterator.__$lsl_States.Initialized, 
                /* parent = */ this, 
                /* cursor = */ 0
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::spliterator(DoubleStream) -> Spliterator_OfDouble
     */
    public Spliterator.OfDouble spliterator() {
        Spliterator.OfDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = Engine.makeSymbolic(Spliterator.OfDouble.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::isParallel(DoubleStream) -> boolean
     */
    public boolean isParallel() {
        boolean result = false;
        /* body */ {
            result = this.isParallel;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::sequential(DoubleStream) -> DoubleStream
     */
    public DoubleStream sequential() {
        DoubleStream result = null;
        /* body */ {
            this.isParallel = false;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::parallel(DoubleStream) -> DoubleStream
     */
    public DoubleStream parallel() {
        DoubleStream result = null;
        /* body */ {
            this.isParallel = true;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::unordered(DoubleStream) -> DoubleStream
     */
    public DoubleStream unordered() {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::onClose(DoubleStream, Runnable) -> DoubleStream
     */
    public DoubleStream onClose(Runnable closeHandler) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final int listLength = this.closeHandlers.size();
            this.closeHandlers.insert(listLength, closeHandler);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::close(DoubleStream) -> void
     */
    public void close() {
        /* body */ {
            final int listLength = this.closeHandlers.size();
            int i = 0;
            for (i = 0; i < listLength; i += 1) {
                final Runnable currentHandler = ((Runnable) this.closeHandlers.get(i));
                currentHandler.run();
            }
            ;
            this.closeHandlers = Engine.makeSymbolicList();
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::dropWhile(DoubleStream, DoublePredicate) -> DoubleStream
     */
    public DoubleStream dropWhile(DoublePredicate predicate) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final double[] emptyStorage = new double[0];
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ emptyStorage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                Engine.assume(this.length > 0);
                int dropLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    dropLength += 1;
                    i += 1;
                }
                ;
                if (dropLength == 0) {
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ this.storage, 
                        /* length = */ this.length, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final int newLength = this.length - dropLength;
                    final double[] newStorage = new double[newLength];
                    int j = dropLength;
                    i = dropLength;
                    while (i < this.length) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ newStorage, 
                        /* length = */ newLength, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::takeWhile(DoubleStream, DoublePredicate) -> DoubleStream
     */
    public DoubleStream takeWhile(DoublePredicate predicate) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final double[] emptyStorage = new double[0];
                result = new DoubleStreamLSL((Void) null, 
                    /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ emptyStorage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                Engine.assume(this.length > 0);
                int takeLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    takeLength += 1;
                    i += 1;
                }
                ;
                if (takeLength == this.length) {
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ this.storage, 
                        /* length = */ this.length, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final int newLength = takeLength;
                    final double[] newStorage = new double[newLength];
                    int j = 0;
                    i = 0;
                    while (i < takeLength) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new DoubleStreamLSL((Void) null, 
                        /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ newStorage, 
                        /* length = */ newLength, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::sum(DoubleStream) -> double
     */
    public double sum() {
        double result = 0.0d;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _sum();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::average(DoubleStream) -> OptionalDouble
     */
    public OptionalDouble average() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                double curSum = _sum();
                double divisionResult = curSum / this.length;
                result = OptionalDouble.of(divisionResult);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::summaryStatistics(DoubleStream) -> DoubleSummaryStatistics
     */
    public DoubleSummaryStatistics summaryStatistics() {
        DoubleSummaryStatistics result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new DoubleSummaryStatistics();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                result.accept(storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] DoubleStreamAutomaton::boxed(DoubleStream) -> Stream
     */
    public Stream boxed() {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Double[] doubleArray = new Double[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                doubleArray[i] = storage[i];
            }
            ;
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ doubleArray, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(DoubleStreamLSL.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
