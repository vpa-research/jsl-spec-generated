// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.util.stream;

import generated.java.util.StreamLSLSpliterator;
import generated.runtime.LibSLGlobals;
import java.lang.Comparable;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.Runnable;
import java.lang.Void;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Optional;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.function.ToDoubleFunction;
import java.util.function.ToIntFunction;
import java.util.function.ToLongFunction;
import java.util.stream.BaseStream;
import java.util.stream.Collector;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import org.usvm.api.SymbolicList;
import runtime.LibSLRuntime;

/**
 * StreamAutomaton for StreamLSL ~> java.util.stream.StreamLSL
 */
@Approximate(stub.java.util.stream.StreamLSL.class)
public class StreamLSL implements LibSLRuntime.Automaton, Stream {
    static {
        Engine.assume(true);
    }

    private byte __$lsl_state = __$lsl_States.Allocated;

    public Object[] storage;

    public transient int length;

    public SymbolicList<Runnable> closeHandlers;

    public boolean isParallel;

    public boolean linkedOrConsumed;

    @LibSLRuntime.AutomatonConstructor
    public StreamLSL(Void __$lsl_token, final byte p0, final Object[] p1, final int p2,
            final SymbolicList<Runnable> p3, final boolean p4, final boolean p5) {
        this.__$lsl_state = p0;
        this.storage = p1;
        this.length = p2;
        this.closeHandlers = p3;
        this.isParallel = p4;
        this.linkedOrConsumed = p5;
    }

    @LibSLRuntime.AutomatonConstructor
    public StreamLSL(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Allocated, null, 0, null, false, false);
    }

    /**
     * [SUBROUTINE] StreamAutomaton::_actionApply(Consumer) -> void
     */
    private void _actionApply(Consumer _action) {
        /* body */ {
            if (_action == null) {
                throw new NullPointerException();
            }
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                _action.accept(storage[i]);
            }
            ;
        }
    }

    /**
     * [SUBROUTINE] StreamAutomaton::_findFirst() -> Optional
     */
    private Optional _findFirst() {
        Optional result = null;
        /* body */ {
            if (this.length == 0) {
                result = Optional.empty();
            } else {
                final Object first = storage[0];
                result = Optional.ofNullable(first);
            }
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::filter(Stream, Predicate) -> Stream
     */
    public Stream filter(Predicate predicate) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            Object[] filteredStorage = new Object[this.length];
            int filteredLength = 0;
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                if (predicate.test(storage[i])) {
                    filteredStorage[filteredLength] = storage[i];
                    filteredLength += 1;
                }
            }
            ;
            Engine.assume(filteredLength <= this.length);
            Object[] resultStorage = new Object[filteredLength];
            LibSLRuntime.ArrayActions.copy(filteredStorage, 0, resultStorage, 0, filteredLength);
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ resultStorage, 
                /* length = */ filteredLength, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::map(Stream, Function) -> Stream
     */
    public Stream map(Function mapper) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            Object[] mappedStorage = new Object[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.apply(storage[i]);
            }
            ;
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::mapToInt(Stream, ToIntFunction) -> IntStream
     */
    public IntStream mapToInt(ToIntFunction mapper) {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            final int[] mappedStorage = new int[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsInt(storage[i]);
            }
            ;
            result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::mapToLong(Stream, ToLongFunction) -> LongStream
     */
    public LongStream mapToLong(ToLongFunction mapper) {
        LongStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            long[] mappedStorage = new long[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsLong(storage[i]);
            }
            ;
            result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::mapToDouble(Stream, ToDoubleFunction) -> DoubleStream
     */
    public DoubleStream mapToDouble(ToDoubleFunction mapper) {
        DoubleStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            double[] mappedStorage = new double[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsDouble(storage[i]);
            }
            ;
            result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ mappedStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::flatMap(Stream, Function) -> Stream
     */
    public Stream flatMap(Function mapper) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(Stream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::flatMapToInt(Stream, Function) -> IntStream
     */
    public IntStream flatMapToInt(Function mapper) {
        IntStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::flatMapToLong(Stream, Function) -> LongStream
     */
    public LongStream flatMapToLong(Function mapper) {
        LongStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(LongStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::flatMapToDouble(Stream, Function) -> DoubleStream
     */
    public DoubleStream flatMapToDouble(Function mapper) {
        DoubleStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(DoubleStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::distinct(Stream) -> Stream
     */
    public Stream distinct() {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            Object[] distinctStorage = null;
            int distinctLength = 0;
            final int size = this.length;
            if (size == 0) {
                distinctStorage = new Object[0];
                distinctLength = 0;
            } else {
                final Object[] items = this.storage;
                Engine.assume(items != null);
                Engine.assume(items.length != 0);
                Engine.assume(size == items.length);
                int i = 0;
                int j = 0;
                final SymbolicList<Object> uniqueItems = Engine.makeSymbolicList();
                final LibSLRuntime.Map<Object, Object> visited = new LibSLRuntime.Map<>(new LibSLRuntime.HashMapContainer<>());
                for (i = 0; i < size; i += 1) {
                    final Object item = items[i];
                    if (!visited.hasKey(item)) {
                        visited.set(item, LibSLGlobals.SOMETHING);
                        uniqueItems.insert(j, item);
                        j += 1;
                    }
                }
                ;
                distinctLength = j;
                Engine.assume(distinctLength > 0);
                Engine.assume(distinctLength <= size);
                distinctStorage = new Object[distinctLength];
                for (i = 0; i < distinctLength; i += 1) {
                    distinctStorage[i] = uniqueItems.get(i);
                }
                ;
            }
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ distinctStorage, 
                /* length = */ distinctLength, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::sorted(Stream) -> Stream
     */
    public Stream sorted() {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                Engine.assume(this.length > 0);
                final int outerLimit = this.length - 1;
                int innerLimit = 0;
                int i = 0;
                int j = 0;
                for (i = 0; i < outerLimit; i += 1) {
                    innerLimit = (this.length - i) - 1;
                    for (j = 0; j < innerLimit; j += 1) {
                        final int idxA = j;
                        final int idxB = j + 1;
                        final Object a = storage[idxA];
                        final Object b = storage[idxB];
                        if (((Comparable) a).compareTo(b) > 0) {
                            storage[idxA] = b;
                            storage[idxB] = a;
                        }
                    }
                    ;
                }
                ;
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::sorted(Stream, Comparator) -> Stream
     */
    public Stream sorted(Comparator comparator) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                final int outerLimit = this.length - 1;
                int innerLimit = 0;
                int i = 0;
                int j = 0;
                for (i = 0; i < outerLimit; i += 1) {
                    innerLimit = (this.length - i) - 1;
                    for (j = 0; j < innerLimit; j += 1) {
                        final int idxA = j;
                        final int idxB = j + 1;
                        final Object a = storage[idxA];
                        final Object b = storage[idxB];
                        if (comparator.compare(a, b) > 0) {
                            storage[idxA] = b;
                            storage[idxB] = a;
                        }
                    }
                    ;
                }
                ;
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::peek(Stream, Consumer) -> Stream
     */
    public Stream peek(Consumer _action) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::limit(Stream, long) -> Stream
     */
    public Stream limit(long maxSize) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (maxSize < 0) {
                throw new IllegalArgumentException();
            }
            if (maxSize == 0) {
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                if (maxSize > this.length) {
                    result = new StreamLSL((Void) null, 
                        /* state = */ StreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ this.storage, 
                        /* length = */ this.length, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final int maxSizeInt = ((int) maxSize);
                    final Object[] limitStorage = new Object[maxSizeInt];
                    int i = 0;
                    for (i = 0; i < maxSizeInt; i += 1) {
                        limitStorage[i] = storage[i];
                    }
                    ;
                    result = new StreamLSL((Void) null, 
                        /* state = */ StreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ limitStorage, 
                        /* length = */ maxSizeInt, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::skip(Stream, long) -> Stream
     */
    public Stream skip(long n) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int offset = ((int) n);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (offset < 0) {
                throw new IllegalArgumentException();
            }
            if (offset == 0) {
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                if (offset >= this.length) {
                    Object[] newArray = {};
                    result = new StreamLSL((Void) null, 
                        /* state = */ StreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ newArray, 
                        /* length = */ 0, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                } else {
                    final int newLength = this.length - offset;
                    final Object[] skipStorage = new Object[newLength];
                    int i = 0;
                    int skipIndex = 0;
                    for (i = offset; i < this.length; i += 1) {
                        skipStorage[skipIndex] = storage[i];
                        skipIndex += 1;
                    }
                    ;
                    result = new StreamLSL((Void) null, 
                        /* state = */ StreamLSL.__$lsl_States.Initialized, 
                        /* storage = */ skipStorage, 
                        /* length = */ newLength, 
                        /* closeHandlers = */ this.closeHandlers, 
                        /* isParallel = */ false, 
                        /* linkedOrConsumed = */ false
                    );
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::forEach(Stream, Consumer) -> void
     */
    public void forEach(Consumer _action) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] StreamAutomaton::forEachOrdered(Stream, Consumer) -> void
     */
    public void forEachOrdered(Consumer _action) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] StreamAutomaton::toArray(Stream) -> array<Object>
     */
    public Object[] toArray() {
        Object[] result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.storage;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::toArray(Stream, IntFunction) -> array<Object>
     */
    public Object[] toArray(IntFunction generator) {
        Object[] result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Object[] generatedArray = ((Object[]) generator.apply(this.length));
            LibSLRuntime.ArrayActions.copy(this.storage, 0, generatedArray, 0, this.length);
            result = generatedArray;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::reduce(Stream, Object, BinaryOperator) -> Object
     */
    public Object reduce(Object identity, BinaryOperator accumulator) {
        Object result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            result = identity;
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result = accumulator.apply(result, storage[i]);
                }
                ;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::reduce(Stream, BinaryOperator) -> Optional
     */
    public Optional reduce(BinaryOperator accumulator) {
        Optional result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            Object value = null;
            if (this.length == 0) {
                result = Optional.empty();
            } else {
                if (this.length > 0) {
                    value = storage[0];
                    int i = 0;
                    for (i = 1; i < this.length; i += 1) {
                        value = accumulator.apply(value, storage[i]);
                    }
                    ;
                    result = Optional.ofNullable(value);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::reduce(Stream, Object, BiFunction, BinaryOperator) -> Object
     */
    public Object reduce(Object identity, BiFunction accumulator, BinaryOperator combiner) {
        Object result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (combiner == null) {
                throw new NullPointerException();
            }
            result = identity;
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result = accumulator.apply(result, storage[i]);
                }
                ;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::collect(Stream, Supplier, BiConsumer, BiConsumer) -> Object
     */
    public Object collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner) {
        Object result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (supplier == null) {
                throw new NullPointerException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (combiner == null) {
                throw new NullPointerException();
            }
            result = supplier.get();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                accumulator.accept(result, storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::collect(Stream, Collector) -> Object
     */
    public Object collect(Collector collector) {
        Object result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (collector == null) {
                throw new NullPointerException();
            }
            int i = 0;
            final BiConsumer accumulator = collector.accumulator();
            for (i = 0; i < this.length; i += 1) {
                accumulator.accept(result, storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::min(Stream, Comparator) -> Optional
     */
    public Optional min(Comparator comparator) {
        Optional result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (comparator == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                result = Optional.empty();
            } else {
                Object min = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (comparator.compare(min, storage[i]) > 0) {
                        min = storage[i];
                    }
                }
                ;
                result = Optional.ofNullable(min);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::max(Stream, Comparator) -> Optional
     */
    public Optional max(Comparator comparator) {
        Optional result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (comparator == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                result = Optional.empty();
            } else {
                Object max = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (comparator.compare(max, storage[i]) < 0) {
                        max = storage[i];
                    }
                }
                ;
                result = Optional.ofNullable(max);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::count(Stream) -> long
     */
    public long count() {
        long result = 0L;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.length;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::anyMatch(Stream, Predicate) -> boolean
     */
    public boolean anyMatch(Predicate predicate) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = false;
            int i = 0;
            while ((i < this.length) && !predicate.test(storage[i])) {
                i += 1;
            }
            ;
            if (i < this.length) {
                result = true;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::allMatch(Stream, Predicate) -> boolean
     */
    public boolean allMatch(Predicate predicate) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::noneMatch(Stream, Predicate) -> boolean
     */
    public boolean noneMatch(Predicate predicate) {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && !predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::findFirst(Stream) -> Optional
     */
    public Optional findFirst() {
        Optional result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::findAny(Stream) -> Optional
     */
    public Optional findAny() {
        Optional result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::iterator(Stream) -> Iterator
     */
    public Iterator iterator() {
        Iterator result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new StreamLSLIterator((Void) null, 
                /* state = */ StreamLSLIterator.__$lsl_States.Initialized, 
                /* parent = */ this, 
                /* cursor = */ 0
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::spliterator(Stream) -> Spliterator
     */
    public Spliterator spliterator() {
        Spliterator result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final int default_characteristics = LibSLGlobals.SPLITERATOR_ORDERED | LibSLGlobals.SPLITERATOR_SIZED | LibSLGlobals.SPLITERATOR_SUBSIZED;
            result = new StreamLSLSpliterator((Void) null, 
                /* state = */ StreamLSLSpliterator.__$lsl_States.Initialized, 
                /* parent = */ this, 
                /* characteristics = */ default_characteristics, 
                /* fence = */ this.length, 
                /* index = */ 0
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::isParallel(Stream) -> boolean
     */
    public boolean isParallel() {
        boolean result = false;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = this.isParallel;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::sequential(Stream) -> BaseStream
     */
    public BaseStream sequential() {
        BaseStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.isParallel = false;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::parallel(Stream) -> BaseStream
     */
    public BaseStream parallel() {
        BaseStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.isParallel = true;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::unordered(Stream) -> BaseStream
     */
    public BaseStream unordered() {
        BaseStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new StreamLSL((Void) null, 
                /* state = */ StreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false
            );
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::onClose(Stream, Runnable) -> BaseStream
     */
    public BaseStream onClose(Runnable arg0) {
        BaseStream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final int listLength = this.closeHandlers.size();
            this.closeHandlers.insert(listLength, arg0);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::close(Stream) -> void
     */
    public void close() {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int listLength = this.closeHandlers.size();
            int i = 0;
            for (i = 0; i < listLength; i += 1) {
                final Runnable currentHandler = ((Runnable) this.closeHandlers.get(i));
                currentHandler.run();
            }
            ;
            this.closeHandlers = Engine.makeSymbolicList();
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] StreamAutomaton::dropWhile(Stream, Predicate) -> Stream
     */
    public Stream dropWhile(Predicate predicate) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final Object[] emptyStorage = new Object[0];
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ emptyStorage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                int dropLength = 0;
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    if (predicate.test(storage[i])) {
                        dropLength += 1;
                    } else {
                        break;
                    }
                }
                ;
                final int newLength = this.length - dropLength;
                final Object[] newStorage = new Object[newLength];
                int j = 0;
                for (i = dropLength; i < this.length; i += 1) {
                    newStorage[j] = storage[i];
                    j += 1;
                }
                ;
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] StreamAutomaton::takeWhile(Stream, Predicate) -> Stream
     */
    public Stream takeWhile(Predicate predicate) {
        Stream result = null;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final Object[] emptyStorage = new Object[0];
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ emptyStorage, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            } else {
                int takeLength = 0;
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    if (predicate.test(storage[i])) {
                        takeLength += 1;
                    } else {
                        break;
                    }
                }
                ;
                final int newLength = takeLength;
                final Object[] newStorage = new Object[newLength];
                int j = 0;
                for (i = 0; i < takeLength; i += 1) {
                    newStorage[j] = storage[i];
                    j += 1;
                }
                ;
                result = new StreamLSL((Void) null, 
                    /* state = */ StreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false
                );
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Allocated = (byte) 0;

        public static final byte Initialized = (byte) 1;
    }

    @Approximate(StreamLSL.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
