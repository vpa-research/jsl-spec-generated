// Generated by the LibSL translator.  DO NOT EDIT!
// source: ?
//
package generated.java.util.stream;

import generated.runtime.LibSLGlobals;
import java.lang.IllegalArgumentException;
import java.lang.IllegalStateException;
import java.lang.Integer;
import java.lang.NullPointerException;
import java.lang.Object;
import java.lang.Runnable;
import java.lang.Void;
import java.util.IntSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.IntBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.IntPredicate;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.ObjIntConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import org.usvm.api.SymbolicList;
import runtime.LibSLRuntime;

/**
 * IntStreamAutomaton for IntStreamLSL ~> java.util.stream.IntStreamLSL
 */
@Approximate(stub.java.util.stream.IntStreamLSL.class)
public class IntStreamLSL implements LibSLRuntime.Automaton, IntStream {
    static {
        Engine.assume(true);
    }

    public int[] storage;

    public transient int length;

    public SymbolicList<Runnable> closeHandlers;

    public boolean isParallel;

    public boolean linkedOrConsumed;

    @LibSLRuntime.AutomatonConstructor
    public IntStreamLSL(Void __$lsl_token, final byte p0, final int[] p1, final int p2,
            final SymbolicList<Runnable> p3, final boolean p4, final boolean p5) {
        this.storage = p1;
        this.length = p2;
        this.closeHandlers = p3;
        this.isParallel = p4;
        this.linkedOrConsumed = p5;
    }

    @LibSLRuntime.AutomatonConstructor
    public IntStreamLSL(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Initialized, null, 0, null, false, false);
    }

    /**
     * [SUBROUTINE] IntStreamAutomaton::_actionApply(IntConsumer) -> void
     */
    private void _actionApply(IntConsumer _action) {
        /* body */ {
            if (_action == null) {
                throw new NullPointerException();
            }
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                _action.accept(storage[i]);
            }
            ;
        }
    }

    /**
     * [SUBROUTINE] IntStreamAutomaton::_findFirst() -> OptionalInt
     */
    private OptionalInt _findFirst() {
        OptionalInt result = null;
        /* body */ {
            if (this.length == 0) {
                result = OptionalInt.empty();
            } else {
                final int first = storage[0];
                result = OptionalInt.of(first);
            }
        }
        return result;
    }

    /**
     * [SUBROUTINE] IntStreamAutomaton::_sum() -> int
     */
    private int _sum() {
        int result = 0;
        /* body */ {
            result = 0;
            if (this.length != 0) {
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result += storage[i];
                }
                ;
            }
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::filter(IntStream, IntPredicate) -> IntStream
     */
    public IntStream filter(IntPredicate predicate) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            int[] filteredStorage = new int[this.length];
            int filteredLength = 0;
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                if (predicate.test(storage[i])) {
                    filteredStorage[filteredLength] = storage[i];
                    filteredLength += 1;
                }
            }
            ;
            Engine.assume(filteredLength <= this.length);
            int[] resultStorage = new int[filteredLength];
            LibSLRuntime.ArrayActions.copy(filteredStorage, 0, resultStorage, 0, filteredLength);
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ resultStorage, 
            /* length = */ filteredLength, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::map(IntStream, IntUnaryOperator) -> IntStream
     */
    public IntStream map(IntUnaryOperator mapper) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            int[] mappedStorage = new int[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsInt(storage[i]);
            }
            ;
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::mapToObj(IntStream, IntFunction) -> Stream
     */
    public Stream mapToObj(IntFunction mapper) {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Object[] objStorage = new Object[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                objStorage[i] = mapper.apply(storage[i]);
            }
            ;
            result = new StreamLSL((Void) null, 
            /* state = */ StreamLSL.__$lsl_States.Initialized, 
            /* storage = */ objStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::mapToLong(IntStream, IntToLongFunction) -> LongStream
     */
    public LongStream mapToLong(IntToLongFunction mapper) {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            long[] mappedStorage = new long[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsLong(storage[i]);
            }
            ;
            result = new LongStreamLSL((Void) null, 
            /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::mapToDouble(IntStream, IntToDoubleFunction) -> DoubleStream
     */
    public DoubleStream mapToDouble(IntToDoubleFunction mapper) {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            double[] mappedStorage = new double[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                mappedStorage[i] = mapper.applyAsDouble(storage[i]);
            }
            ;
            result = new DoubleStreamLSL((Void) null, 
            /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ mappedStorage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::flatMap(IntStream, IntFunction) -> IntStream
     */
    public IntStream flatMap(IntFunction mapper) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (mapper == null) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolic(IntStream.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::sorted(IntStream) -> IntStream
     */
    public IntStream sorted() {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                final int outerLimit = this.length - 1;
                int innerLimit = 0;
                int i = 0;
                int j = 0;
                for (i = 0; i < outerLimit; i += 1) {
                    innerLimit = (this.length - i) - 1;
                    for (j = 0; j < innerLimit; j += 1) {
                        final int idxA = j;
                        final int idxB = j + 1;
                        final int a = storage[idxA];
                        final int b = storage[idxB];
                        if (a > b) {
                            storage[idxA] = b;
                            storage[idxB] = a;
                        }
                    }
                    ;
                }
                ;
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::distinct(IntStream) -> IntStream
     */
    public IntStream distinct() {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            int[] distinctStorage = null;
            int distinctLength = 0;
            final int size = this.length;
            if (size == 0) {
                distinctStorage = new int[0];
                distinctLength = 0;
            } else {
                final int[] items = this.storage;
                Engine.assume(items != null);
                Engine.assume(items.length != 0);
                Engine.assume(size == items.length);
                int i = 0;
                int j = 0;
                final SymbolicList<Integer> uniqueItems = Engine.makeSymbolicList();
                final LibSLRuntime.Map<Integer, Object> visited = new LibSLRuntime.Map<>(new LibSLRuntime.HashMapContainer<>());
                for (i = 0; i < size; i += 1) {
                    final int item = items[i];
                    if (!visited.hasKey(item)) {
                        visited.set(item, LibSLGlobals.SOMETHING);
                        uniqueItems.insert(j, item);
                        j += 1;
                    }
                }
                ;
                distinctLength = j;
                Engine.assume(distinctLength > 0);
                Engine.assume(distinctLength <= size);
                distinctStorage = new int[distinctLength];
                for (i = 0; i < distinctLength; i += 1) {
                    final Integer item = uniqueItems.get(i);
                    Engine.assume(item != null);
                    distinctStorage[i] = ((int) item);
                }
                ;
            }
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ distinctStorage, 
            /* length = */ distinctLength, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::peek(IntStream, IntConsumer) -> IntStream
     */
    public IntStream peek(IntConsumer _action) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ this.storage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::limit(IntStream, long) -> IntStream
     */
    public IntStream limit(long maxSize) {
        IntStream result = null;
        /* body */ {
            final int maxSizeInt = ((int) maxSize);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (maxSizeInt < 0) {
                throw new IllegalArgumentException();
            }
            if (maxSizeInt == 0) {
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                if (maxSizeInt > this.length) {
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int[] limitStorage = new int[maxSizeInt];
                    LibSLRuntime.ArrayActions.copy(this.storage, 0, limitStorage, 0, maxSizeInt);
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ limitStorage, 
                    /* length = */ maxSizeInt, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::skip(IntStream, long) -> IntStream
     */
    public IntStream skip(long n) {
        IntStream result = null;
        /* body */ {
            final int offset = ((int) n);
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (offset < 0) {
                throw new IllegalArgumentException();
            }
            if (offset == 0) {
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ this.storage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                if (offset >= this.length) {
                    int[] newArray = {};
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newArray, 
                    /* length = */ 0, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = this.length - offset;
                    final int[] skipStorage = new int[newLength];
                    int i = 0;
                    int skipIndex = 0;
                    for (i = offset; i < this.length; i += 1) {
                        skipStorage[skipIndex] = storage[i];
                        skipIndex += 1;
                    }
                    ;
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ skipStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::forEach(IntStream, IntConsumer) -> void
     */
    public void forEach(IntConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] IntStreamAutomaton::forEachOrdered(IntStream, IntConsumer) -> void
     */
    public void forEachOrdered(IntConsumer _action) {
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            _actionApply(_action);
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] IntStreamAutomaton::toArray(IntStream) -> array<int>
     */
    public int[] toArray() {
        int[] result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.storage;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::reduce(IntStream, int, IntBinaryOperator) -> int
     */
    public int reduce(int identity, IntBinaryOperator accumulator) {
        int result = 0;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            result = identity;
            if (this.length != 0) {
                Engine.assume(this.length > 0);
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    result = accumulator.applyAsInt(result, storage[i]);
                }
                ;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::reduce(IntStream, IntBinaryOperator) -> OptionalInt
     */
    public OptionalInt reduce(IntBinaryOperator accumulator) {
        OptionalInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                result = OptionalInt.empty();
            } else {
                if (this.length > 0) {
                    int value = storage[0];
                    int i = 0;
                    for (i = 1; i < this.length; i += 1) {
                        value = accumulator.applyAsInt(value, storage[i]);
                    }
                    ;
                    result = OptionalInt.of(value);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::collect(IntStream, Supplier, ObjIntConsumer, BiConsumer) -> Object
     */
    public Object collect(Supplier supplier, ObjIntConsumer accumulator, BiConsumer combiner) {
        Object result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (supplier == null) {
                throw new NullPointerException();
            }
            if (accumulator == null) {
                throw new NullPointerException();
            }
            if (combiner == null) {
                throw new NullPointerException();
            }
            result = supplier.get();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                accumulator.accept(result, storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::min(IntStream) -> OptionalInt
     */
    public OptionalInt min() {
        OptionalInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalInt.empty();
            } else {
                int min = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (min > storage[i]) {
                        min = storage[i];
                    }
                }
                ;
                result = OptionalInt.of(min);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::max(IntStream) -> OptionalInt
     */
    public OptionalInt max() {
        OptionalInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalInt.empty();
            } else {
                int max = storage[0];
                int i = 0;
                for (i = 1; i < this.length; i += 1) {
                    if (max < storage[i]) {
                        max = storage[i];
                    }
                }
                ;
                result = OptionalInt.of(max);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::count(IntStream) -> long
     */
    public long count() {
        long result = 0L;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = this.length;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::anyMatch(IntStream, IntPredicate) -> boolean
     */
    public boolean anyMatch(IntPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = false;
            int i = 0;
            while ((i < this.length) && !predicate.test(storage[i])) {
                i += 1;
            }
            ;
            if (i < this.length) {
                result = true;
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::allMatch(IntStream, IntPredicate) -> boolean
     */
    public boolean allMatch(IntPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::noneMatch(IntStream, IntPredicate) -> boolean
     */
    public boolean noneMatch(IntPredicate predicate) {
        boolean result = false;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            result = true;
            if (this.length > 0) {
                result = false;
                int i = 0;
                while ((i < this.length) && !predicate.test(storage[i])) {
                    i += 1;
                }
                ;
                if (i == this.length) {
                    result = true;
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::findFirst(IntStream) -> OptionalInt
     */
    public OptionalInt findFirst() {
        OptionalInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::findAny(IntStream) -> OptionalInt
     */
    public OptionalInt findAny() {
        OptionalInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _findFirst();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::iterator(IntStream) -> PrimitiveIterator_OfInt
     */
    public PrimitiveIterator.OfInt iterator() {
        PrimitiveIterator.OfInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new IntStreamLSLIterator((Void) null, 
            /* state = */ IntStreamLSLIterator.__$lsl_States.Initialized, 
            /* parent = */ this, 
            /* cursor = */ 0);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::spliterator(IntStream) -> Spliterator_OfInt
     */
    public Spliterator.OfInt spliterator() {
        Spliterator.OfInt result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = Engine.makeSymbolic(Spliterator.OfInt.class);
            Engine.assume(result != null);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::isParallel(IntStream) -> boolean
     */
    public boolean isParallel() {
        boolean result = false;
        /* body */ {
            result = this.isParallel;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::sequential(IntStream) -> IntStream
     */
    public IntStream sequential() {
        IntStream result = null;
        /* body */ {
            this.isParallel = false;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::parallel(IntStream) -> IntStream
     */
    public IntStream parallel() {
        IntStream result = null;
        /* body */ {
            this.isParallel = true;
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::unordered(IntStream) -> IntStream
     */
    public IntStream unordered() {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new IntStreamLSL((Void) null, 
            /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
            /* storage = */ this.storage, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::onClose(IntStream, Runnable) -> IntStream
     */
    public IntStream onClose(Runnable closeHandler) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final int listLength = this.closeHandlers.size();
            this.closeHandlers.insert(listLength, closeHandler);
            result = this;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::close(IntStream) -> void
     */
    public void close() {
        /* body */ {
            final int listLength = this.closeHandlers.size();
            int i = 0;
            for (i = 0; i < listLength; i += 1) {
                final Runnable currentHandler = ((Runnable) this.closeHandlers.get(i));
                currentHandler.run();
            }
            ;
            this.closeHandlers = Engine.makeSymbolicList();
            this.linkedOrConsumed = true;
        }
    }

    /**
     * [FUNCTION] IntStreamAutomaton::dropWhile(IntStream, IntPredicate) -> IntStream
     */
    public IntStream dropWhile(IntPredicate predicate) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final int[] emptyStorage = new int[0];
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyStorage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                int dropLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    dropLength += 1;
                    i += 1;
                }
                ;
                if (dropLength == 0) {
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = this.length - dropLength;
                    final int[] newStorage = new int[newLength];
                    int j = dropLength;
                    i = dropLength;
                    while (i < this.length) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::takeWhile(IntStream, IntPredicate) -> IntStream
     */
    public IntStream takeWhile(IntPredicate predicate) {
        IntStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (predicate == null) {
                throw new NullPointerException();
            }
            if (this.length == 0) {
                final int[] emptyStorage = new int[0];
                result = new IntStreamLSL((Void) null, 
                /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyStorage, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                int takeLength = 0;
                int i = 0;
                while ((i < this.length) && predicate.test(storage[i])) {
                    takeLength += 1;
                    i += 1;
                }
                ;
                if (takeLength == this.length) {
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ this.storage, 
                    /* length = */ this.length, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                } else {
                    final int newLength = takeLength;
                    final int[] newStorage = new int[newLength];
                    int j = 0;
                    i = 0;
                    while (i < takeLength) {
                        newStorage[j] = storage[i];
                        j += 1;
                        i += 1;
                    }
                    ;
                    result = new IntStreamLSL((Void) null, 
                    /* state = */ IntStreamLSL.__$lsl_States.Initialized, 
                    /* storage = */ newStorage, 
                    /* length = */ newLength, 
                    /* closeHandlers = */ this.closeHandlers, 
                    /* isParallel = */ false, 
                    /* linkedOrConsumed = */ false);
                }
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::asLongStream(IntStream) -> LongStream
     */
    public LongStream asLongStream() {
        LongStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                final long[] emptyArray = {};
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyArray, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                final long[] newStorage = new long[this.length];
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    newStorage[i] = ((long) storage[i]);
                }
                ;
                result = new LongStreamLSL((Void) null, 
                /* state = */ LongStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ newStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::asDoubleStream(IntStream) -> DoubleStream
     */
    public DoubleStream asDoubleStream() {
        DoubleStream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                final double[] emptyArray = {};
                result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ emptyArray, 
                /* length = */ 0, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            } else {
                Engine.assume(this.length > 0);
                final double[] newStorage = new double[this.length];
                int i = 0;
                for (i = 0; i < this.length; i += 1) {
                    newStorage[i] = ((double) storage[i]);
                }
                ;
                result = new DoubleStreamLSL((Void) null, 
                /* state = */ DoubleStreamLSL.__$lsl_States.Initialized, 
                /* storage = */ newStorage, 
                /* length = */ this.length, 
                /* closeHandlers = */ this.closeHandlers, 
                /* isParallel = */ false, 
                /* linkedOrConsumed = */ false);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::sum(IntStream) -> int
     */
    public int sum() {
        int result = 0;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = _sum();
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::average(IntStream) -> OptionalDouble
     */
    public OptionalDouble average() {
        OptionalDouble result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            if (this.length == 0) {
                result = OptionalDouble.empty();
            } else {
                double curSum = _sum();
                double divisionResult = curSum / this.length;
                result = OptionalDouble.of(divisionResult);
            }
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::summaryStatistics(IntStream) -> IntSummaryStatistics
     */
    public IntSummaryStatistics summaryStatistics() {
        IntSummaryStatistics result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            result = new IntSummaryStatistics();
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                result.accept(storage[i]);
            }
            ;
            this.linkedOrConsumed = true;
        }
        return result;
    }

    /**
     * [FUNCTION] IntStreamAutomaton::boxed(IntStream) -> Stream
     */
    public Stream boxed() {
        Stream result = null;
        /* body */ {
            if (this.linkedOrConsumed) {
                throw new IllegalStateException();
            }
            final Integer[] integerArray = new Integer[this.length];
            int i = 0;
            for (i = 0; i < this.length; i += 1) {
                integerArray[i] = storage[i];
            }
            ;
            result = new StreamLSL((Void) null, 
            /* state = */ StreamLSL.__$lsl_States.Initialized, 
            /* storage = */ integerArray, 
            /* length = */ this.length, 
            /* closeHandlers = */ this.closeHandlers, 
            /* isParallel = */ false, 
            /* linkedOrConsumed = */ false);
            this.linkedOrConsumed = true;
        }
        return result;
    }

    public static final class __$lsl_States {
        public static final byte Initialized = (byte) 0;
    }

    @Approximate(IntStreamLSL.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
