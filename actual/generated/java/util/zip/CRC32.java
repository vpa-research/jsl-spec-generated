// Generated by the LibSL translator.  DO NOT EDIT!
// sources:
//  - java/util/zip/CRC32.lsl:23
//  - java/util/zip/CRC32.automaton.lsl:17
//
package generated.java.util.zip;

import java.lang.ArrayIndexOutOfBoundsException;
import java.lang.AssertionError;
import java.lang.NullPointerException;
import java.lang.SuppressWarnings;
import java.lang.Void;
import java.nio.ByteBuffer;
import java.util.zip.Checksum;
import org.jacodb.approximation.annotation.Approximate;
import org.usvm.api.Engine;
import runtime.LibSLRuntime;
import sun.nio.ch.DirectBuffer;

/**
 * CRC32Automaton for LSLCRC32 ~> java.util.zip.CRC32
 */
@SuppressWarnings({"all", "unchecked"})
@Approximate(java.util.zip.CRC32.class)
public class CRC32 implements LibSLRuntime.Automaton, Checksum {
    static {
        Engine.assume(true);
    }

    private byte __$lsl_state = __$lsl_States.Allocated;

    public int crc;

    @LibSLRuntime.AutomatonConstructor
    public CRC32(Void __$lsl_token, final byte p0, final int p1) {
        this.__$lsl_state = p0;
        this.crc = p1;
    }

    @LibSLRuntime.AutomatonConstructor
    public CRC32(final Void __$lsl_token) {
        this(__$lsl_token, __$lsl_States.Allocated, 0);
    }

    /**
     * [CONSTRUCTOR] CRC32Automaton::<init>(CRC32) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:98
     */
    public CRC32() {
        this((Void) null);
        Engine.assume(this.__$lsl_state == __$lsl_States.Allocated);
        /* body */ {
        }
        this.__$lsl_state = __$lsl_States.Initialized;
    }

    /**
     * [SUBROUTINE] CRC32Automaton::_updateCheck(array<byte>, int, int) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:49
     */
    private void _updateCheck(byte[] b, int off, int len) {
        /* body */ {
            if (b == null) {
                throw new NullPointerException();
            }
            final int b_size = b.length;
            if ((off < 0) || (len < 0) || (off > (b_size - len))) {
                throw new ArrayIndexOutOfBoundsException();
            }
        }
    }

    /**
     * [SUBROUTINE] CRC32Automaton::_updateByteBuffer(long) -> int
     * Source: java/util/zip/CRC32.automaton.lsl:60
     */
    private int _updateByteBuffer(long addr) {
        int result = 0;
        /* body */ {
            if (addr == 0L) {
                throw new NullPointerException();
            }
            result = Engine.makeSymbolicInt();
        }
        return result;
    }

    /**
     * [SUBROUTINE] CRC32Automaton::_updateBytesCheck(array<byte>, int, int) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:74
     */
    private void _updateBytesCheck(byte[] b, int off, int len) {
        /* body */ {
            if (len != 0) {
                if (b != null) {
                    final int b_size = b.length;
                    Engine.assume(b_size >= 0);
                    if ((off < 0) || (off >= b_size)) {
                        throw new ArrayIndexOutOfBoundsException(off);
                    }
                    final int endIndex = (off + len) - 1;
                    if ((endIndex < 0) || (endIndex >= b_size)) {
                        throw new ArrayIndexOutOfBoundsException(endIndex);
                    }
                } else {
                    throw new NullPointerException();
                }
            }
        }
    }

    /**
     * [FUNCTION] CRC32Automaton::getValue(CRC32) -> long
     * Source: java/util/zip/CRC32.automaton.lsl:108
     */
    public long getValue() {
        long result = 0L;
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            result = ((long) this.crc) & 4294967295L;
        }
        return result;
    }

    /**
     * [FUNCTION] CRC32Automaton::reset(CRC32) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:114
     */
    public void reset() {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.crc = 0;
        }
    }

    /**
     * [FUNCTION] CRC32Automaton::update(CRC32, ByteBuffer) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:120
     */
    public void update(ByteBuffer buffer) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int pos = buffer.position();
            final int limit = buffer.limit();
            if (pos > limit) {
                throw new AssertionError();
            }
            final int rem = limit - pos;
            if (rem > 0) {
                if ((buffer instanceof DirectBuffer)) {
                    final DirectBuffer directBuffer = ((DirectBuffer) buffer);
                    final long address = directBuffer.address();
                    this.crc = _updateByteBuffer(address);
                } else {
                    if (buffer.hasArray()) {
                        final int off = buffer.arrayOffset() + pos;
                        final byte[] bufferArray = buffer.array();
                        _updateBytesCheck(bufferArray, off, rem);
                        this.crc = Engine.makeSymbolicInt();
                    } else {
                        int len = 4096;
                        final int b_rem = buffer.remaining();
                        if (b_rem < len) {
                            len = b_rem;
                        }
                        final byte[] b = new byte[len];
                        final int b_size = b.length;
                        Engine.assume(b_size >= 0);
                        while (buffer.hasRemaining()) {
                            int length = buffer.remaining();
                            if (b_size < length) {
                                length = b_size;
                            }
                            buffer.get(b, 0, length);
                            _updateCheck(b, 0, length);
                            _updateBytesCheck(b, 0, length);
                        }
                        ;
                        this.crc = Engine.makeSymbolicInt();
                    }
                }
                buffer.position(limit);
            }
        }
    }

    /**
     * [FUNCTION] CRC32Automaton::update(CRC32, array<byte>) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:177
     */
    public void update(byte[] b) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            final int len = b.length;
            Engine.assume(len >= 0);
            _updateCheck(b, 0, len);
            _updateBytesCheck(b, 0, len);
            this.crc = Engine.makeSymbolicInt();
        }
    }

    /**
     * [FUNCTION] CRC32Automaton::update(CRC32, array<byte>, int, int) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:187
     */
    public void update(byte[] b, int off, int len) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            _updateCheck(b, off, len);
            _updateBytesCheck(b, off, len);
            this.crc = Engine.makeSymbolicInt();
        }
    }

    /**
     * [FUNCTION] CRC32Automaton::update(CRC32, int) -> void
     * Source: java/util/zip/CRC32.automaton.lsl:195
     */
    public void update(int b) {
        Engine.assume(this.__$lsl_state == __$lsl_States.Initialized);
        /* body */ {
            this.crc = Engine.makeSymbolicInt();
        }
    }

    public static final class __$lsl_States {
        public static final byte Allocated = (byte) 0;

        public static final byte Initialized = (byte) 1;
    }

    @Approximate(CRC32.class)
    public static final class __hook {
        private __hook(Void o1, Void o2) {
            Engine.assume(false);
        }
    }
}
